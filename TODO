- [70%] Types
- [x] Conversions
- [ ] Define "source paths"
- [ ] Describe operations like GetQNameInNsSetOrAnyPublicNs() and possibly others used in property lookup
- [70%] Property lookup
  - https://github.com/whackengine/sdk/blob/master/crates/mxmlsemantics/src/semantics/property_lookup.rs#L353
  - [x] PropertyLookup: remind of `meta` stuff
    - [x] `meta::get` allows for multiple signatures
    - [ ] Introduce lazily imported source files based in source paths, when lookuping from packages.
    - [ ] Values whose static type is a type parameter will lookup for names in the type parameter's derived types.
  - [ ] InScopeLookup
    - [ ] Introduce lazily imported source files based in source paths.
    - [ ] `env` qualifier causes DotEnv variable retrieval (or, depending on the implementation, may resolve to a predefined variable).
    - [ ] Use `fixed=true` access when doing property lookup in activation's `this` (e.g. user should use `this` if the enclosing class is dynamic and needs to access a dynamic property).
- [ ] Constants
  - [ ] *EnumConstant* for both regular enumerations and flag enumerations
- [ ] Reference values
  - [ ] *DynamicReferenceValue*(*base*, *qual*, *key*.Value, *followedByCall*, *fixed*)
  - [ ] *KeyValuePairReferenceValue*(*base*, *meta-method*, *qual*, *key*)
  - [ ] Do not include XML reference values from Whack Engine
- [70%] Packages
- [70%] Namespaces
- [70%] Classes
- [70%] Enumerations
- [70%] Interfaces
- [70%] Variables
- [70%] Virtual variables
- [70%] Methods
- [x] Aliases
- [x] Generics
- [x] Lexical scopes
- [x] Default lexical scope
- [x] Conditional compilation
- [x] ESDoc comments
- [x] Meta-methods
- [x] Lexical conventions
- [ ] ShockScript: Expressions
  - [x] `Embed()`
    - [x] URL behavior
    - [x] `"text/plain""`
    - [x] `"application/octet-stream"`
  - [ ] Qualified identifier
  - [x] Fixed expression (FixedExpression)
    - `<?fixed={}?>`
  - [ ] String literal
    - [ ] Is applicable to enumerations (also check for union)
  - [ ] XML expression
    - [ ] XML literals applied as `XML`/`XMLList` shall still resolve namespace prefixes to lexical ShockScript names. (`namespace` definitions may be used as prefixes as well (definition name = URI); with implicit prefix.)
  - [ ] Null literal
  - [ ] Array literal
    - [ ] Is applicable to flag enumerations
  - [x] All literal `**` (AllLiteral)
  - [ ] Object initializer
    - [ ] Applicable to flag enumerations
  - [ ] Parenthesized expression
    - [ ] Does not propagate *followedByCall=true*
    - [ ] Propagates *fixed=true* from given context
  - [ ] Dot operator
    - [ ] Propagates *fixed=true* from given context
  - [ ] Brackets operator
    - [ ] Propagates *fixed=true* from given context
  - [ ] Descendants operator
    - [ ] Takes a non-attribute qualified identifier.
  - [ ] Call operator
    - [ ] Base is passed *followedByCall=true*
    - [ ] Watch for static `meta::call` when calling classes (supports multiple signatures too)
    - [ ] `XML` and `XMLList` being called statically shall still pass themselves as the context type to the first call argument, even if they define `meta::call()`.
    - [ ] Perform type inference for omitted generic parameters.
  - [ ] `v as T` operator
    - [ ] Passes context type `T` to `v`
  - [ ] Assignment expression
    - [ ] When base is *KeyValuePairReferenceValue*, `meta::set()`
    - [ ] When base is *AttributeReferenceValue*, `meta::setAttribute()`
  - [ ] Delete operator
    - [ ] `meta::delete()`
    - [ ] `meta::deleteAttribute()`
  - [ ] New operator
    - [ ] Base is passed *followedByCall=true*
    - [ ] Support a dynamically typed base (`*` or `Class`)
    - [ ] Forbid instantiating `abstract` or `static` classes.
    - [ ] Forbid instantiating enumerations.
  - [ ] Null coalescing `x ?? y`
    - [ ] Pass x type to y
- [x] ShockScript: Type expressions
  - [ ] Semantics
- [x] ShockScript: Patterns (Pattern, ArrayPattern, ObjectPattern)
  - [ ] Semantics
- [x] ShockScript: Statements
  - [ ] Semantics
  - [ ] For `for each`: `Iterator` and `Iterable` are iterable
- [x] ShockScript: Directives
  - [ ] Semantics
- [x] ShockScript: Definitions
  - [ ] Semantics
- [ ] Global objects
  - [ ] (Whack engine) w namespace = "http://www.sweaxizone.com/2015/whack"
  - [ ] ES4 namespace = "http://www.sweaxizone.com/2015/shockscript/global"
  - [ ] Intl namespace = "org.shockscript.intl"
  - [ ] Temporal namespace = "org.shockscript.temporal"
  - [ ] env namespace (DotEnv special qualifier) = "http://www.sweaxizone.com/2015/shockscript/env"
  - [ ] trace()
  - [ ] etrace()
  - [ ] assert() (a namespace-method)
  - [ ] assert.equal() (uses `Object#equals()`)
  - [ ] assert.throws()
  - [ ] encodeURI()
  - [ ] decodeURI()
  - [ ] encodeURIComponent()
  - [ ] decodeURIComponent()
  - [ ] isNaN()
  - [ ] isFinite()
  - [ ] parseInt()
  - [ ] parseFloat()
  - [ ] Infinity
  - [ ] NaN
  - [ ] undefined
  - [ ] Iterator.\<T> (interface)
    - [ ] required `next():[T]?` (the returned array must be of length 1)
    - [ ] `length():int` (consumes the whole iterator)
    - [ ] `skip(count:int):void`
    - [ ] `meta::filter(...)` (returns another iterator)
    - [ ] Other functional methods (iterator *helper methods* like `map`, `every`, `some`, `reduce`...)
  - [ ] Iterable.\<K, V> (interface) requires keys() and values()
  - [ ] Generator.\<T>
  - [ ] Comparable interface
    - [ ] `compareTo(obj:Object):int`
    - [ ] This is used by default on array sorting.
  - [ ] Object
    - [ ] `clone(deep:boolean=):Object`
      - \[protected]
      - Default implementation clones most objects fine (records, tuples, arrays, maps and so on), but fails for classes with a required constructor.
        - Clones are shallow (not deep) by default
    - [ ] `equals(obj:Object):boolean`
      - [ ] NaN = NaN
      - [ ] Maps
      - [ ] Array
      - [ ] Tuples
      - [ ] Records
      - [ ] Maps
      - [ ] (Other objects just use ===)
    - [ ] `meta::class()`
    - [ ] toString()
    - [ ] toLocaleString()
    - [ ] valueOf()
  - [ ] Array
    - [ ] `meta::get(...)` throws if out of bounds
    - [ ] `meta::filter(...)`
    - [ ] `clone(deep=)`
    - [ ] `shift(): (void, T)`
    - [ ] `pop(): (void, T)`
    - [ ] `first : (void, T)`
    - [ ] `last : (void, T)`
  - [ ] Map
    - [ ] `Map(weakKeys:boolean = false)`
    - [ ] `meta::get()` throws if key does not match
    - [ ] `length()`
    - [ ] `clear()`
    - [ ] `clone(deep=)`
  - [ ] string
    - [ ] static `fromByte(...):string`
    - [ ] `format(vars:Map.<string, string>):string`
      - Formats `$varName`, `${varName}` and `$$`
  - [ ] Chars
    - [ ] `new Chars(str:string, offset:int = 0)`
    - [ ] Indexing (peeking using zero-based Unicode code point positions; returns U+00 if out of bounds)
    - [ ] `seq(numCodePoints:int):string` (stops on end of stream)
    - [ ] `peek():uint` (equivalent to `chars[0]`)
    - [ ] `reachedEnd:boolean`
    - [ ] `hasRemaining:boolean`
    - [ ] `clone(deep=):Chars`
  - [ ] RegExpMatches
    - [ ] Implement indexing
    - [ ] `substr : [string]`
    - [ ] `clone(deep=)`
  - [ ] XML
    - [ ] Implement `Iterable`
    - [ ] static `meta::call(arg:*):XML`
    - [ ] `meta::has(name:QName):boolean`
    - [ ] `meta::get(index:int):XML` (throws if out of bounds)
    - [ ] `meta::get(name:QName):XMLList`
    - [ ] `meta::set(key:(int, QName), value:(XML, XMLList)):void`
    - [ ] `meta::delete(arg:(int, QName)):boolean`
    - [ ] Attributes
  - [ ] XMLList
    - [ ] static `meta::call(arg:*):XMLList`
  - [ ] ByteArray
    - [ ] Indexing
    - [ ] `shareable:boolean`
    - [ ] `clone(deep=)`
  - [ ] org.shockscript.intl.*
    - [ ] Like ECMA-262 `Intl`. Aliased `Intl::`, as well.
  - [ ] org.shockscript.temporal.*
    - [ ] Like ECMA-262 like `Temporal`. Aliased `Temporal::`, as well.
  - [ ] org.shockscript.reflect.*
    - Used for what the `reflect` namespace cannot be used for (e.g. perhaps extracting a list of properties from a package name).