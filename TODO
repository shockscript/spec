- [70%] Types
- [x] Conversions
- [ ] Define "source paths"
- [ ] Describe operations like GetQNameInNsSetOrAnyPublicNs() and possibly others used in property lookup
- [70%] Property lookup
  - https://github.com/whackengine/sdk/blob/master/crates/mxmlsemantics/src/semantics/property_lookup.rs#L353
  - [x] PropertyLookup: remind of `sx_proxy` stuff
    - [x] `sx_proxy::get` allows for multiple signatures
    - [ ] Introduce lazily imported source files based in source paths, when lookuping from packages.
    - [ ] Values whose static type is a type parameter will lookup for names in the type parameter's derived types.
  - [ ] InScopeLookup
    - [ ] Introduce lazily imported source files based in source paths.
    - [ ] `DotEnv` qualifier causes DotEnv variable retrieval.
    - [ ] Use `fixed=true` access when doing property lookup in activation's `this` (e.g. user should use `this` if the enclosing class is dynamic and needs to access a dynamic property).
- [ ] Constants
  - [ ] *EnumConstant* for both regular enumerations and flag enumerations
- [ ] Reference values
  - [ ] *DynamicReferenceValue*(*base*, *qual*, *key*.Value, *followedByCall*, *fixed*)
  - [ ] *KeyValuePairReferenceValue*(*base*, *proxy method*, *qual*, *key*)
  - [ ] Do not include XML reference values from Whack Engine
- [70%] Packages
- [70%] Namespaces
- [70%] Classes
- [70%] Enumerations
- [70%] Interfaces
- [70%] Variables
- [70%] Virtual variables
- [70%] Methods
- [x] Aliases
- [x] Generics
- [x] Lexical scopes
- [x] Default lexical scope
- [x] Conditional compilation
- [x] SXDoc comments
- [x] Proxies
- [x] Lexical conventions
- [ ] Expressions
  - [ ] `Embed()`
    - [ ] URL behavior
    - [ ] `String`
    - [ ] `ByteArray`
  - [ ] Qualified identifier
  - [ ] Fixed expression (FixedExpression)
    - `<?fixed={}?>`
  - [ ] String literal
    - [ ] Is applicable to enumerations (also check for union)
  - [ ] XML expression
    - [ ] XML literals applied as `XML`/`XMLList` shall resolve namespace prefixes to lexical ShockScript names. (`namespace` definitions may be used as prefixes as well (definition name = URI); with implicit prefix.)
  - [ ] Null literal
  - [ ] Array literal
    - [ ] Is applicable to flag enumerations
  - [x] All literal `**` (AllLiteral)
  - [ ] Object initializer
    - [ ] Applicable to flag enumerations
  - [ ] Parenthesized expression
    - [ ] Does not propagate *followedByCall=true*
    - [ ] Propagates *fixed=true* from given context
  - [ ] Dot operator
    - [ ] Propagates *fixed=true* from given context
  - [ ] Brackets operator
    - [ ] Propagates *fixed=true* from given context
  - [ ] Descendants operator
    - [ ] Takes a non-attribute qualified identifier.
  - [ ] Call operator
    - [ ] Base is passed *followedByCall=true*
    - [ ] Watch for static `sx_proxy::call` when calling classes (supports multiple signatures too)
    - [ ] Take in consideration compatible overrides and overloads (also important for the `[object Object].equals()` method (e.g. in case two types are entirely different, should use the basemost `.equals()` method (essentially a dummy `===` comparison)))
    - [ ] `XML` and `XMLList` being called statically shall still pass themselves as the context type to the first call argument, even if they define `sx_proxy::call()`.
  - [ ] `v as T` operator
    - [ ] Passes context type `T` to `v`
  - [ ] Assignment expression
    - [ ] When base is *KeyValuePairReferenceValue*, `sx_proxy::set()`
    - [ ] When base is *AttributeReferenceValue*, `sx_proxy::setAttribute()`
  - [ ] Delete operator
    - [ ] `sx_proxy::delete()`
    - [ ] `sx_proxy::deleteAttribute()`
  - [ ] New operator
    - [ ] Base is passed *followedByCall=true*
    - [ ] Support a dynamically typed base (`*` or `Class`)
    - [ ] Forbid instantiating `abstract` or `static` classes.
    - [ ] Forbid instantiating enumerations.
  - [ ] Null coalescing `x ?? y`
    - [ ] Pass x type to y
- [ ] Type expressions
  - [ ] Record types
    - [ ] Support field in namespaces `::`
  - [ ] `?T` or `T?`
  - [ ] `T!`
- [ ] Statements
  - [ ] For `for each`: `Iterator` and `Iterable` are iterable
  - [ ] `switch`
    - [ ] No fallthroughs (demonstrate too).
  - [ ] `switch type`
- [ ] Directives
- [ ] Definition constructs
- [ ] Global objects
  - [ ] sx_proxy namespace
  - [ ] DotEnv namespace
  - [ ] Reflect namespace
  - [ ] trace()
  - [ ] assert()
  - [ ] assertEquals()
  - [ ] assertThrows()
  - [ ] encodeURI()
  - [ ] decodeURI()
  - [ ] encodeURIComponent()
  - [ ] decodeURIComponent()
  - [ ] isNaN()
  - [ ] isFinite()
  - [ ] parseInt()
  - [ ] parseFloat()
  - [ ] Infinity
  - [ ] NaN
  - [ ] undefined
  - [ ] Iterator.\<T> (interface)
    - [ ] required `next():{ done: Boolean, value?: T }`
    - [ ] `length():int`
    - [ ] `skip(count:int):void`
    - [ ] `sx_proxy::filter(...)` (returns another iterator)
    - [ ] Other functional methods
  - [ ] Iterable.\<K, V> (interface) requires keys() and values()
  - [ ] Generator.\<T>
  - [ ] Comparable interface
    - [ ] `compareTo(obj:this):int`
    - [ ] This is used by default on array sorting (as long as element types are equal)
  - [ ] Object
    - [ ] Reflect::class()
    - [ ] clone() returns `this`
      - Default implementation clones most objects fine (records, tuples, arrays, maps and so on), but classes with a required constructor will require a custom clone() override.
    - [ ] `equals(obj:this):Boolean`
      - May be used in addition to reference equality (==, ===). Default object behavior is ===.
      - Incompatible operands should use the most compatible base `.equals()` method (call operator specific behavior)
      - Floating points should have an `equals()` implementation done like in React.js's memoization/state new value comparison.
      - [ ] `Map.equals()` should look structurally using inner `.equals()`
      - [ ] Array too
      - [ ] Tuples too
      - [ ] Records too
    - [ ] toString()
    - [ ] toLocaleString()
    - [ ] valueOf()
  - [ ] Array
    - [ ] `sx_proxy::get(...)` throws if out of bounds
    - [ ] `sx_proxy::filter(...)`
    - [ ] `clone()`
    - [ ] `shift(): (void, T)`
    - [ ] `pop(): (void, T)`
    - [ ] `first : (void, T)`
    - [ ] `last : (void, T)`
  - [ ] Map
    - [ ] `Map(weakKeys:Boolean = false)`
    - [ ] `sx_proxy::get()` throws if key does not match
    - [ ] `length()`
    - [ ] `clear()`
    - [ ] `clone()`
  - [ ] String
    - [ ] static `fromByte(...):String`
    - [ ] `format(vars:Map.<String, String>):String`
      - Formats `$varName`, `${varName}` and `$$`
  - [ ] Chars
    - [ ] `new Chars(str:String, offset:int = 0)`
    - [ ] Indexing (peeking using zero-based Unicode code point positions; returns U+00 if out of bounds)
    - [ ] `seq(numCodePoints:int):String` (stops on end of stream)
    - [ ] `peek():uint` (equivalent to `chars[0]`)
    - [ ] `reachedEnd:Boolean`
    - [ ] `hasRemaining:Boolean`
    - [ ] `clone():Chars`
  - [ ] RegExpMatches
    - [ ] Implement indexing
    - [ ] `substr : [String]`
    - [ ] `clone()`
  - [ ] XML
    - [ ] Implement `Iterable`
    - [ ] static `sx_proxy::call(arg:*):XML`
    - [ ] `sx_proxy::has(name:QName):Boolean`
    - [ ] `sx_proxy::get(index:int):XML` (throws if out of bounds)
    - [ ] `sx_proxy::get(name:QName):XMLList`
    - [ ] `sx_proxy::set(key:(int, QName), value:(XML, XMLList)):void`
    - [ ] `sx_proxy::delete(arg:(int, QName)):Boolean`
    - [ ] Attributes
  - [ ] XMLList
    - [ ] static `sx_proxy::call(arg:*):XMLList`
  - [ ] ByteArray
    - [ ] Indexing
    - [ ] `shareable:Boolean`
    - [ ] `clone()`
  - [ ] sx.intl.*
    - [ ] Like ECMA-262 `Intl`. Aliased globally as `Intl::` for clarity.
    - [ ] Do not define subpackages for consistency with `Intl::`.
  - [ ] sx.temporal.*
    - [ ] Defines ECMA-262 like `Temporal` functionality, including classes and methods. That package is aliased globally as `Temporal::` for clarity.
    - [ ] Do not define subpackages for consistency with `Temporal::`.