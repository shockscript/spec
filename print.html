<!DOCTYPE HTML>
<html lang="en" class="light sidebar-visible" dir="ltr">
    <head>
        <!-- Book generated using mdBook -->
        <meta charset="UTF-8">
        <title>ShockScript Language Specification</title>
        <meta name="robots" content="noindex">


        <!-- Custom HTML head -->

        <meta name="description" content="">
        <meta name="viewport" content="width=device-width, initial-scale=1">
        <meta name="theme-color" content="#ffffff">

        <link rel="shortcut icon" href="favicon.png">
        <link rel="stylesheet" href="css/variables.css">
        <link rel="stylesheet" href="css/general.css">
        <link rel="stylesheet" href="css/chrome.css">
        <link rel="stylesheet" href="css/print.css" media="print">

        <!-- Fonts -->
        <link rel="stylesheet" href="FontAwesome/css/font-awesome.css">
        <link rel="stylesheet" href="fonts/fonts.css">

        <!-- Highlight.js Stylesheets -->
        <link rel="stylesheet" id="highlight-css" href="highlight.css">
        <link rel="stylesheet" id="tomorrow-night-css" href="tomorrow-night.css">
        <link rel="stylesheet" id="ayu-highlight-css" href="ayu-highlight.css">

        <!-- Custom theme stylesheets -->


        <!-- Provide site root and default themes to javascript -->
        <script>
            const path_to_root = "";
            const default_light_theme = "light";
            const default_dark_theme = "navy";
        </script>
        <!-- Start loading toc.js asap -->
        <script src="toc.js"></script>
    </head>
    <body>
    <div id="body-container">
        <!-- Work around some values being stored in localStorage wrapped in quotes -->
        <script>
            try {
                let theme = localStorage.getItem('mdbook-theme');
                let sidebar = localStorage.getItem('mdbook-sidebar');

                if (theme.startsWith('"') && theme.endsWith('"')) {
                    localStorage.setItem('mdbook-theme', theme.slice(1, theme.length - 1));
                }

                if (sidebar.startsWith('"') && sidebar.endsWith('"')) {
                    localStorage.setItem('mdbook-sidebar', sidebar.slice(1, sidebar.length - 1));
                }
            } catch (e) { }
        </script>

        <!-- Set the theme before any content is loaded, prevents flash -->
        <script>
            const default_theme = window.matchMedia("(prefers-color-scheme: dark)").matches ? default_dark_theme : default_light_theme;
            let theme;
            try { theme = localStorage.getItem('mdbook-theme'); } catch(e) { }
            if (theme === null || theme === undefined) { theme = default_theme; }
            const html = document.documentElement;
            html.classList.remove('light')
            html.classList.add(theme);
            html.classList.add("js");
        </script>

        <input type="checkbox" id="sidebar-toggle-anchor" class="hidden">

        <!-- Hide / unhide sidebar before it is displayed -->
        <script>
            let sidebar = null;
            const sidebar_toggle = document.getElementById("sidebar-toggle-anchor");
            if (document.body.clientWidth >= 1080) {
                try { sidebar = localStorage.getItem('mdbook-sidebar'); } catch(e) { }
                sidebar = sidebar || 'visible';
            } else {
                sidebar = 'hidden';
            }
            sidebar_toggle.checked = sidebar === 'visible';
            html.classList.remove('sidebar-visible');
            html.classList.add("sidebar-" + sidebar);
        </script>

        <nav id="sidebar" class="sidebar" aria-label="Table of contents">
            <!-- populated by js -->
            <mdbook-sidebar-scrollbox class="sidebar-scrollbox"></mdbook-sidebar-scrollbox>
            <noscript>
                <iframe class="sidebar-iframe-outer" src="toc.html"></iframe>
            </noscript>
            <div id="sidebar-resize-handle" class="sidebar-resize-handle">
                <div class="sidebar-resize-indicator"></div>
            </div>
        </nav>

        <div id="page-wrapper" class="page-wrapper">

            <div class="page">
                <div id="menu-bar-hover-placeholder"></div>
                <div id="menu-bar" class="menu-bar sticky">
                    <div class="left-buttons">
                        <label id="sidebar-toggle" class="icon-button" for="sidebar-toggle-anchor" title="Toggle Table of Contents" aria-label="Toggle Table of Contents" aria-controls="sidebar">
                            <i class="fa fa-bars"></i>
                        </label>
                        <button id="theme-toggle" class="icon-button" type="button" title="Change theme" aria-label="Change theme" aria-haspopup="true" aria-expanded="false" aria-controls="theme-list">
                            <i class="fa fa-paint-brush"></i>
                        </button>
                        <ul id="theme-list" class="theme-popup" aria-label="Themes" role="menu">
                            <li role="none"><button role="menuitem" class="theme" id="default_theme">Auto</button></li>
                            <li role="none"><button role="menuitem" class="theme" id="light">Light</button></li>
                            <li role="none"><button role="menuitem" class="theme" id="rust">Rust</button></li>
                            <li role="none"><button role="menuitem" class="theme" id="coal">Coal</button></li>
                            <li role="none"><button role="menuitem" class="theme" id="navy">Navy</button></li>
                            <li role="none"><button role="menuitem" class="theme" id="ayu">Ayu</button></li>
                        </ul>
                        <button id="search-toggle" class="icon-button" type="button" title="Search. (Shortkey: s)" aria-label="Toggle Searchbar" aria-expanded="false" aria-keyshortcuts="S" aria-controls="searchbar">
                            <i class="fa fa-search"></i>
                        </button>
                    </div>

                    <h1 class="menu-title">ShockScript Language Specification</h1>

                    <div class="right-buttons">
                        <a href="print.html" title="Print this book" aria-label="Print this book">
                            <i id="print-button" class="fa fa-print"></i>
                        </a>

                    </div>
                </div>

                <div id="search-wrapper" class="hidden">
                    <form id="searchbar-outer" class="searchbar-outer">
                        <input type="search" id="searchbar" name="searchbar" placeholder="Search this book ..." aria-controls="searchresults-outer" aria-describedby="searchresults-header">
                    </form>
                    <div id="searchresults-outer" class="searchresults-outer hidden">
                        <div id="searchresults-header" class="searchresults-header"></div>
                        <ul id="searchresults">
                        </ul>
                    </div>
                </div>

                <!-- Apply ARIA attributes after the sidebar and the sidebar toggle button are added to the DOM -->
                <script>
                    document.getElementById('sidebar-toggle').setAttribute('aria-expanded', sidebar === 'visible');
                    document.getElementById('sidebar').setAttribute('aria-hidden', sidebar !== 'visible');
                    Array.from(document.querySelectorAll('#sidebar a')).forEach(function(link) {
                        link.setAttribute('tabIndex', sidebar === 'visible' ? 0 : -1);
                    });
                </script>

                <div id="content" class="content">
                    <main>
                        <h1 id="overview"><a class="header" href="#overview">Overview</a></h1>
<p>ShockScript is a strongly typed, multi-paradigm scripting language.</p>
<blockquote>
<p><strong>Note</strong>: The document is a work in progress, and may lack content.</p>
</blockquote>
<h2 id="extensible-markup-language"><a class="header" href="#extensible-markup-language">eXtensible Markup Language</a></h2>
<p>ShockScript incorporates eXtensible Markup Language (XML) expressions suitable for implementing User Interfaces (UI), and also includes capabilities for users interested on XML data processing.</p>
<p>For the Whack Engine, XML expressions create WhackDS nodes by default.</p>
<h2 id="events"><a class="header" href="#events">Events</a></h2>
<p>ShockScript incorporates a basic event model and allows easily declaring event types and documenting them. Implementations may extend the event model for working with a Document Object Model.</p>
<h2 id="shockdoc-comments"><a class="header" href="#shockdoc-comments">ShockDoc comments</a></h2>
<p>ShockScript supports documentation comments allowing for Markdown notation, special tags such as <code>@throws</code> and media inclusion.</p>
<div style="break-before: page; page-break-before: always;"></div><h1 id="embedding-resources"><a class="header" href="#embedding-resources">Embedding resources</a></h1>
<p>The <code>Embed()</code> expression may be used for embedding files and media into the program. Its default behavior is to return a <code>data:</code> (for small files) or external URL (for large files).</p>
<pre><code>Embed("thumb.webp")
</code></pre>
<blockquote>
<p><strong>Note</strong>: When returning an external URL, implementations such as Whack Engine use the <code>app://</code> scheme to fetch a file in the application's installation directory.</p>
</blockquote>
<blockquote>
<p><strong>Note</strong>: Implementations may support an artifact path interpolation, as in:</p>
<pre><code>Embed("{target}/auto.generated")
</code></pre>
<p>That is useful when a build script is involved that generates files at the artifact path.</p>
</blockquote>
<h2 id="including-statically"><a class="header" href="#including-statically">Including statically</a></h2>
<p>The user may embed files statically as either an UTF-8 encoded string, or <code>ByteArray</code>, rather than obtaining an URL.</p>
<pre><code>Embed("data.txt", "text/plain")
Embed("data.bin", "application/octet-stream")
</code></pre>
<div style="break-before: page; page-break-before: always;"></div><h1 id="relation-to-other-technologies"><a class="header" href="#relation-to-other-technologies">Relation to other technologies</a></h1>
<p>This section compares ShockScript to other technologies and languages.</p>
<div style="break-before: page; page-break-before: always;"></div><h1 id="reactjs"><a class="header" href="#reactjs">React.js</a></h1>
<p>ShockScript incorporates XML capabilities, and XML expressions allow for implementations to produce anything desired, similiar to JSX. There are certain differences to JSX or React.js.</p>
<p>The following demonstrates a basic XML expression for WhackDS:</p>
<pre><code>&lt;w:HGroup&gt;
    &lt;w:Button click&amp;={trace("clicked!")}&gt;button 1&lt;/w:Button&gt;
&lt;/w:HGroup&gt;
</code></pre>
<h2 id="event-handlers"><a class="header" href="#event-handlers">Event handlers</a></h2>
<p>In ShockScript, event handlers are expressed as <code>e&amp;={statementList}</code> (note the ampersand <strong>&amp;</strong>) as a shorthand to <code>e={function(event){statementList}}</code>. Furthermore, event handlers are conventionally expressed without an <code>on</code> prefix (for instance, <code>click</code> instead of <code>onClick</code>), and they are documented with the <code>@eventparam</code> tag.</p>
<h2 id="prefixes"><a class="header" href="#prefixes">Prefixes</a></h2>
<p>ShockScript allows for <code>&lt;q:N&gt;</code>, whose name resolution equals <code>q::N</code>. Dots may be used for entities other than namespaces, as in:</p>
<pre><code>&lt;com.business.components.AppBar/&gt;
</code></pre>
<p>For brevity, you do either:</p>
<pre><code>import bc = com.business.components.*;

&lt;bc:AppBar/&gt;
</code></pre>
<p>or:</p>
<pre><code>import com.business.components.*

&lt;AppBar/&gt;
</code></pre>
<h2 id="interpolation"><a class="header" href="#interpolation">Interpolation</a></h2>
<p>Interpolation works similiarly to React.js, except for HTML.</p>
<pre><code>&lt;w:VGroup&gt;
    {undefined}
    {null}
    {node}
    {nodeList}
    {plainText}
    {number}
&lt;/w:VGroup&gt;
</code></pre>
<p>Interpolating attributes uses <code>{ object }</code> and not <code>{ ...object }</code> and must appear at most once at the end of all attributes:</p>
<pre><code>&lt;w:Button {params}&gt;click me&lt;/w:Button&gt;
</code></pre>
<h2 id="states"><a class="header" href="#states">States</a></h2>
<p>Unlike React.js, in WhackDS there is no risk of accessing an outdated state's value, due to how states are constructed.</p>
<pre><code>package com.business.components {
    //
    public function HelloWorld():whack.ds.Node {
        // x
        [State]
        var x:Number = 0;

        // layout
        return (
            &lt;w:VGroup&gt;
                &lt;w:Label&gt;clicked {x} times&lt;/w:Label&gt;
                &lt;w:Button click&amp;={x++}&gt;click me&lt;/w:Button&gt;
            &lt;/w:VGroup&gt;
        );
    }
}
</code></pre>
<p>The state's initializer represents the state's initial value.</p>
<p>Like React.js, there is no transitive detection of mutation methods; therefore, the following is necessary over an array <code>.push(v)</code>:</p>
<pre><code>x = [...x, v];
</code></pre>
<p>As to Map objects:</p>
<pre><code>m = { ...m, k: v };
</code></pre>
<h2 id="bindables"><a class="header" href="#bindables">Bindables</a></h2>
<p>In WhackDS the concept of "refs" is called <em>bindables</em>.</p>
<pre><code>package com.business.components {
    //
    public function HelloWorld():whack.ds.Node {
        [Bindable]
        var button:Button?;

        //
        whack.ds.useEffect(function() {
            trace(button!);
        }, []);

        return (
            &lt;w:Button bind={button}&gt;click me&lt;/w:Button&gt;
        );
    }
}
</code></pre>
<h2 id="contexts"><a class="header" href="#contexts">Contexts</a></h2>
<p>Context usage is represented as <code>whack.ds.ContextValue.&lt;T&gt;</code> objects, although they are used as natural <code>Context</code>-annotated locals.</p>
<pre><code>function ExampleComponent():whack.ds.Node {
    //
    [Context(ExampleContext)]
    const example:Number;

    return (
        &lt;&gt;&lt;/&gt;
    );
}
</code></pre>
<h2 id="effects"><a class="header" href="#effects">Effects</a></h2>
<p>The popular "useEffect" hook requires the second argument, preventing mistakes. For listening to any changes, use <code>"*"</code>.</p>
<pre><code>whack.ds.useEffect(function() {
    //
    return function() {
        // cleanup
    };
}, [dep1, ...depN]);

whack.ds.useEffect(function() {
    //
}, "*");
</code></pre>
<h2 id="styling"><a class="header" href="#styling">Styling</a></h2>
<p>Unlike with React.js, there is built-in support for linking style sheets in a WhackDS component.</p>
<pre><code>&lt;w:Group&gt;
    &lt;w:Style&gt;
        &lt;![CDATA[
            :host {
                background: red;
            }
        ]]&gt;
    &lt;/w:Style&gt;
&lt;/w:Group&gt;
</code></pre>
<p><a href="overview/relation/../xml-capabilities/whack.html#linking-cascading-style-sheets">More on style sheets</a></p>
<div style="break-before: page; page-break-before: always;"></div><h1 id="mxml"><a class="header" href="#mxml">MXML</a></h1>
<p>The MXML language, as part of the Apache Flex framework, was used for describing UI components in an intuitive way. ShockScript uses XML expressions semantically similiar to the React.js + JSX technologies, but designed to feel close to MXML in readability.</p>
<p>The following demonstrates a basic UI component implemented in WhackDS:</p>
<pre><code>package com.business.components {
    //
    public function AppBar():whack.ds.Node {
        return (
            &lt;w:HGroup&gt;
                &lt;w:Button click&amp;={trace("clicked!")}&gt;button 1&lt;/w:Button&gt;
            &lt;/w:HGroup&gt;
        );
    }
}
</code></pre>
<h2 id="event-handlers-1"><a class="header" href="#event-handlers-1">Event handlers</a></h2>
<p>In MXML, event handlers were expressed as <code>e="statements"</code>. In ShockScript, they are expressed as <code>e&amp;={statements}</code> (note the ampersand <strong>&amp;</strong>) as a shorthand to <code>e={function(event){statements}}</code>.</p>
<blockquote>
<p><strong>Note</strong>: Although not demanded as such, as opposed to React.js + DOM, event handlers are conventionally expressed without a <code>on</code> prefix, such as <code>click&amp;={trace("clicked!")}</code> rather than React.js <code>onClick={e=&gt;{console.log("clicked!")}}</code>. Event parameters are conventionally given the <code>@eventparam</code> tag in the ShockDoc comments. Classes continue using the <code>Event</code> meta-data, though without needing the <code>@eventType</code> tag.</p>
</blockquote>
<h2 id="rendering-components"><a class="header" href="#rendering-components">Rendering components</a></h2>
<p>The Whack Engine's WhackDS feature allows programmers to implement UI components as functions that wrap around the built-in class-based components of Whack Engine. The component is rendered by evaluating the function initially and whenever a state changes.</p>
<h2 id="effects-1"><a class="header" href="#effects-1">Effects</a></h2>
<p>The <code>whack.ds.useEffect</code> hook may be used to detect state, parameter or derived changes as well as the component mount and unmount phases.</p>
<pre><code>whack.ds.useEffect(function() {
    // cleanup
    return function() {
        //
    };
}, [dep1, ...depN]);

whack.ds.useEffect(function() {
    //
}, "*");
</code></pre>
<p>When the dependencies list is empty (<code>[]</code>), the hook is equivalent to a component mount/unmount event, with the unmount phase handled through the returned function.</p>
<pre><code>whack.ds.useEffect(function() {
    // did mount
    return function() {
        // unmount
    };
}, []);
</code></pre>
<h2 id="states-1"><a class="header" href="#states-1">States</a></h2>
<p>In the top-level of a component, declare states using the <code>State</code> meta-data:</p>
<pre><code>[State]
var counter:uint = 0;
</code></pre>
<p>The initial value of <code>counter</code> is zero, although that initializer is only assigned to the state the first time the component renders.</p>
<p>Note that, like with React.js, arrays and structures as states will not trigger a re-render on operations like <code>.push()</code>; instead the programmer needs to reconstruct the array or structure, like in:</p>
<pre><code>list = [...list, v];
</code></pre>
<h2 id="bindables-1"><a class="header" href="#bindables-1">Bindables</a></h2>
<p>In the top-level of a WhackDS component, declare bindables by using the <code>Bindable</code> meta-data. Bindables have certain use-cases, such as persisting a value across renders, and extracting class-based components from certain tags (in which case the <code>bind</code> attribute is used).</p>
<pre><code>[Bindable]
var button:Button? = null;

return (
    &lt;w:Button bind={button}&gt;click me&lt;/w:Button&gt;
);
</code></pre>
<h2 id="contexts-1"><a class="header" href="#contexts-1">Contexts</a></h2>
<p>In the top-level of a component, reflect inherited contexts by using the <code>Context</code> meta-data.</p>
<pre><code>[Context(ThemeContext)]
var theme:Theme;
</code></pre>
<h2 id="capture-safety"><a class="header" href="#capture-safety">Capture safety</a></h2>
<p>Unlike in React.js combined with TypeScript, states, bindables ("refs") and context values are captured by reference from nested functions, guaranting the "outdated" value of, say, a state, is never captured, which facilitates development by requiring no additional bindable declaration.</p>
<h2 id="styling-1"><a class="header" href="#styling-1">Styling</a></h2>
<p>Unlike with React.js, there is built-in support for linking style sheets in a WhackDS component.</p>
<pre><code>&lt;w:Group&gt;
    &lt;w:Style&gt;
        &lt;![CDATA[
            :host {
                background: red;
            }
        ]]&gt;
    &lt;/w:Style&gt;
&lt;/w:Group&gt;
</code></pre>
<p><a href="overview/relation/../xml-capabilities/whack.html#linking-cascading-style-sheets">More on style sheets</a></p>
<div style="break-before: page; page-break-before: always;"></div><h1 id="actionscript-3"><a class="header" href="#actionscript-3">ActionScript 3</a></h1>
<p>ShockScript looks like ActionScript 3. This section describes several details that changed on the language.</p>
<h2 id="string-type"><a class="header" href="#string-type">String type</a></h2>
<p>The <code>String</code> type stores an UTF-8 encoded text, not an UTF-16 encoded text.</p>
<pre><code>"\u{10FFFF}".length // UTF-8 length
"\u{10FFFF}".charAt(0) // Code Point at byte 0

for each (var ch in "shockscript".chars()) {
    // ch:uint
}

"shockscript".chars().length() // Code Point length
</code></pre>
<h2 id="include-directive"><a class="header" href="#include-directive">Include directive</a></h2>
<p>The <code>include</code> directive is not included in ShockScript.</p>
<h2 id="default-xml-namespace"><a class="header" href="#default-xml-namespace">Default XML namespace</a></h2>
<p>The <code>default xml namespace =</code> E4X statement is not included in ShockScript due to WebAssembly limitations.</p>
<h2 id="dynamic"><a class="header" href="#dynamic">Dynamic</a></h2>
<p>The <code>Object</code> type is not dynamic per se, nor does it contain <code>undefined</code>, nor are there dynamic classes, nor are there legacy ECMAScript <code>prototype</code> objects. Only the <code>*</code> type is dynamic and contains <code>undefined</code>.</p>
<p><strong>Matching</strong>: The <code>str.match</code> resulting object is slightly different, but still supports indexing.</p>
<p><strong>Obtaining constructor</strong>: <code>o.Reflect::class()</code></p>
<h2 id="nullability"><a class="header" href="#nullability">Nullability</a></h2>
<p>Types except <code>*</code> are non-nullable by default. Use <code>T?</code> or <code>?T</code> as a shorthand to <code>(null, T)</code>, and <code>T!</code> as a way to exclude <code>undefined</code> and/or <code>null</code>.</p>
<h2 id="overriding-methods"><a class="header" href="#overriding-methods">Overriding methods</a></h2>
<ul>
<li>Instance methods may override another method and include additional optional parameters (including the rest parameter).</li>
<li>Instance methods may override another method and return a more contravariant result type.</li>
</ul>
<pre><code>class A {
    function m() {}
}
class B extends A {
    override function m(...rest:[float]) {}
}
</code></pre>
<h2 id="in-operator"><a class="header" href="#in-operator">“in” operator</a></h2>
<p>The <code>in</code> operator behaves differently. It triggers <code>shock_proxy::has()</code> which is in general used for determining whether a collection contains a specific value; for <code>Map</code>s it determines whether a pair key exists; for <code>XML</code> and <code>XMLList</code> objects it performs the same E4X behavior.</p>
<pre><code>trace(e in arr);
trace(k in m);
</code></pre>
<h2 id="filter-operator"><a class="header" href="#filter-operator">Filter operator</a></h2>
<p>The filter operator has been modified to use a <code>*</code> identifier rather than cluttering the lexical scope with dynamic names.</p>
<pre><code>xnode.(*.@x.startsWith("abc"))
</code></pre>
<h2 id="with-statement"><a class="header" href="#with-statement">With statement</a></h2>
<p>The with statement is modified to use the <code>*</code> identifier to avoid cluttering the lexical scope.</p>
<pre><code>with (o) {
    *.x =
    *.y = 10;
}
</code></pre>
<h2 id="this-capture"><a class="header" href="#this-capture">“this” capture</a></h2>
<p>The <code>this</code> object is always captured from the parent activation in nested activations; there is no way to override the <code>this</code> object with another value.</p>
<pre><code>class A {
    function m() {
        function n() {
            // this:A
        }
    }
}
</code></pre>
<h2 id="e4x"><a class="header" href="#e4x">E4X</a></h2>
<p>XML expressions do not produce <code>XML</code> or <code>XMLList</code> unless the inference type is one of these; they are implementation-defined by default. Such expressions have also undergone incremental syntax additions:</p>
<ul>
<li><code>&lt;t a/&gt;</code> equals <code>&lt;t a={true}/&gt;</code></li>
<li><code>&lt;t e&amp;={}/&gt;</code> equals <code>&lt;t e={function(event){}}/&gt;</code> or <code>&lt;t e={function(){}}/&gt;</code></li>
</ul>
<pre><code>&lt;w:VGroup&gt;
    &lt;w:Label variant="heading"&gt;Welcome&lt;/w:Label&gt;
    &lt;w:Button click&amp;={trace("clicked me");}&gt;Click me&lt;/w:Button&gt;
&lt;/w:VGroup&gt;
</code></pre>
<blockquote>
<p><strong>Note</strong>: <code>XML(&lt;tag/&gt;)</code> equals <code>var _loc_0:XML = &lt;tag/&gt;;</code>.</p>
</blockquote>
<h2 id="events-1"><a class="header" href="#events-1">Events</a></h2>
<p>Events are declared without defining related static constants, as ShockScript performs vast type inference; thus, the ASDoc <code>@eventType</code> tag does not exist in ShockScript.</p>
<pre><code>/** Some event */
[Event(name="act", type="Event")]
/** Some class */
class A extends EventTarget {}
</code></pre>
<blockquote>
<p><strong>Note</strong>: The <code>@eventparam</code> tag introduced in ShockScript is used for documenting events better in reactive systems that use record types rather than classes for component parameters.</p>
</blockquote>
<h2 id="embedding"><a class="header" href="#embedding">Embedding</a></h2>
<p>Embedding files is much easier in ShockScript. The following returns typically an <code>app://</code> URI for a file that will be automatically added to the application's installation directory.</p>
<pre><code>trace(Embed("flower.webp"));
</code></pre>
<blockquote>
<p><strong>Note</strong>: Implementations may support interpolating an artifact directory at the <code>Embed</code> path, such as <code>{target}</code>.</p>
<pre><code>trace(Embed("{target}/auto.generated.bin"));
</code></pre>
<p>This is useful for when a build script generates a file at an artifact directory.</p>
</blockquote>
<p>For static embedding, use a second option as either <code>"text/plain"</code> or <code>"application/octet-stream"</code>.</p>
<pre><code>Embed("data.txt", "text/plain")               // :String
Embed("data.bin", "application/octet-stream") // :ByteArray
</code></pre>
<h2 id="variable-shadowing"><a class="header" href="#variable-shadowing">Variable shadowing</a></h2>
<p>In ShockScript the following is valid in an activation:</p>
<pre><code>var m:* = complexCentral.manager;
// more code...
var m = Manager(m);
</code></pre>
<h2 id="switch-fallthroughs"><a class="header" href="#switch-fallthroughs">Switch fallthroughs</a></h2>
<p>The <code>switch</code> statement does not support fallthroughs, which helps preventing logical bugs by not requiring the <code>break</code> statement.</p>
<pre><code>switch (v) {
    case 0:
        trace("zero");
    case 1:
        trace("one");
    default:
        trace("rest");
}
</code></pre>
<h2 id="switch-type"><a class="header" href="#switch-type">Switch type</a></h2>
<p>The <code>switch type</code> statement allows for simple type matching:</p>
<pre><code>switch type (v) {
    case (d : Date) {
        //
    }
    default {
        //
    }
}
</code></pre>
<div style="break-before: page; page-break-before: always;"></div><h1 id="javascript"><a class="header" href="#javascript">JavaScript</a></h1>
<p>ShockScript gets too many roots from JavaScript.</p>
<h2 id="map-data-type"><a class="header" href="#map-data-type">Map data type</a></h2>
<p>The ShockScript's <code>Map</code> data type differs fundamentally from JavaScript's <code>Map</code> in that key-value pairs are accessed more naturally. ShockScript resolves the ambiguity between pairs and the prototype by differentiating property <em>read</em> and <em>call</em>.</p>
<pre><code>m.x = 10
m.length()
</code></pre>
<blockquote>
<p><strong>Note</strong>: For a customized type, it might be necessary to access a variable rather than a key-value pair; for that, the user may use a fixed expression as in <code>&lt;?fixed={object.q::n}?&gt;</code>.</p>
</blockquote>
<h2 id="variable-shadowing-1"><a class="header" href="#variable-shadowing-1">Variable shadowing</a></h2>
<p>In ShockScript the following is valid in an activation:</p>
<pre><code>var m:* = complexCentral.manager;
// more code...
var m = Manager(m);
</code></pre>
<h2 id="not-keyword"><a class="header" href="#not-keyword">“not” keyword</a></h2>
<p><code>not</code> may be used to negate <code>in</code> or <code>is</code> operators:</p>
<pre><code>e not in a
v is not T
</code></pre>
<h2 id="this-binding"><a class="header" href="#this-binding">“this” binding</a></h2>
<p>The <code>this</code> binding is fixed and present only in instance methods.</p>
<ul>
<li>Methods like <code>[object Function].apply()</code> do not take a <code>this</code> binding: only the parameters.</li>
<li>Instance methods are bound.</li>
</ul>
<div style="break-before: page; page-break-before: always;"></div><h1 id="java"><a class="header" href="#java">Java</a></h1>
<h2 id="package-flexibility"><a class="header" href="#package-flexibility">Package flexibility</a></h2>
<p>While importing definitions, the user can alias a definition, or even a package.</p>
<pre><code>package com.business.product.core {
    //
    public class Chart {
        //
    }
}
package com.business.product.core {
    //
    public enum ChartType {
        const BAR;
        const FLOW;
    }
}

import pns = com.business.product.*;
//
const chart_type : pns::ChartType = "flow";
//
const chart = new pns::Chart(chart_type);
</code></pre>
<div style="break-before: page; page-break-before: always;"></div><h1 id="xml-capabilities"><a class="header" href="#xml-capabilities">XML capabilities</a></h1>
<p>The ShockScript language includes XML capabilities.</p>
<h2 id="xml-expressions"><a class="header" href="#xml-expressions">XML expressions</a></h2>
<p>XML expressions by default are used for creating implementation-defined objects; however, when the inference type is <code>XML</code> or <code>XMLList</code>, XML expressions evaluate to one of these types.</p>
<pre><code>package com.business.components {
    //
    public function AppBar():whack.ds.Node {
        return (
            &lt;w:HGroup&gt;
                &lt;w:Button click&amp;={trace("clicked!")}&gt;button 1&lt;/w:Button&gt;
            &lt;/w:HGroup&gt;
        );
    }
}

package com.business.editor {
    //
    public function data(a:String):XML {
        return (
            &lt;tag&gt;{a}&lt;/tag&gt;
        );
    }
}

const xn = XML(&lt;tag/&gt;);
</code></pre>
<h3 id="attributes"><a class="header" href="#attributes">Attributes</a></h3>
<p><code>&lt;t a/&gt;</code> is equivalent to <code>&lt;t a={true}/&gt;</code>. Accessing <code>XML</code> attributes can be directly done by the <code>@</code> operator, as in <code>xnode.@x</code>.</p>
<h3 id="event-handlers-2"><a class="header" href="#event-handlers-2">Event handlers</a></h3>
<p>Inline event handlers may be expressed as <code>eventName&amp;={statementList}</code> as a shortcut to <code>eventName={function(event){statementList}}</code>, as in:</p>
<pre><code>&lt;w:Button click&amp;={trace("clicked!")}&gt;Click me&lt;/w:Button&gt;
</code></pre>
<p>If the event has no parameters, then the attribute above is equivalent to <code>eventName={function(){statementList}}</code>.</p>
<h3 id="interpolation-1"><a class="header" href="#interpolation-1">Interpolation</a></h3>
<pre><code>&lt;w:VGroup {params}&gt;
    {undefined}
    {null}
    {node}
    {nodeList}
    {plainText}
    {number}
&lt;/w:VGroup&gt;
</code></pre>
<h2 id="filtering"><a class="header" href="#filtering">Filtering</a></h2>
<p><code>XML</code> and <code>XMLList</code> implement the filter operator.</p>
<pre><code>xnode.(*.@name == "Diantha")
</code></pre>
<h2 id="descendants"><a class="header" href="#descendants">Descendants</a></h2>
<p><code>XML</code> and <code>XMLList</code> implement the descendants operator.</p>
<pre><code>xnode..tag
</code></pre>
<div style="break-before: page; page-break-before: always;"></div><h1 id="whack"><a class="header" href="#whack">Whack</a></h1>
<p>This section describes XML features specifically when applied as WhackDS nodes.</p>
<h2 id="native-tags"><a class="header" href="#native-tags">Native tags</a></h2>
<p>Native tags belong to the implicit <code>w</code> namespace, such as <code>w:Button</code>. The <code>w</code> namespace is not overridable.</p>
<h2 id="dom-data-attributes"><a class="header" href="#dom-data-attributes">DOM “data” attributes</a></h2>
<p><code>data</code> attributes (like <code>data-x</code>) set over native tags, such as <code>w:Button</code>, contribute plain data attributes to the underlying DOM element.</p>
<p>Using a WhackDS reference, the attribute would be accessed as <code>reference!.@["data-name"]</code>.</p>
<h2 id="key-attribute"><a class="header" href="#key-attribute">“key” attribute</a></h2>
<p>The <code>key</code> attribute is reserved for uniquely identifying interpolated collection items.</p>
<h2 id="linking-cascading-style-sheets"><a class="header" href="#linking-cascading-style-sheets">Linking cascading style sheets</a></h2>
<p><code>&lt;w:Style&gt;</code> tags are used for linking style sheets to the parent tag and passing arguments to the style sheet (which are referred by the style sheet as <code>param(color)</code>).</p>
<pre><code>package com.fun.components {
    //
    public function CustomComponent() {
        return (
            &lt;w:Button&gt;
                &lt;w:Style color="yellow"&gt;
                    &lt;![CDATA[
                        :host { color: param(color) }
                    ]]&gt;
                &lt;/w:Style&gt;

                click me
            &lt;/w:Button&gt;
        );
    }
}
</code></pre>
<p>If the style sheet is too large, it may be moved out of the ShockScript file; for instance:</p>
<pre><code class="language-plain">// CustomComponent.sx
package com.fun.components {
    //
    public function CustomComponent() {
        return (
            &lt;w:Button&gt;
                &lt;w:Style
                    source="CustomComponent.css"
                    color="yellow"/&gt;
                click me
            &lt;/w:Button&gt;
        );
    }
}
/* CustomComponent.css */
:host {
    color: param(color);
}
</code></pre>
<p>Style blocks can be conditional, as in:</p>
<pre><code>&lt;w:Style if={condition}&gt;
    ...
&lt;/w:Style&gt;
</code></pre>
<h4 id="linking-style-sheets-in-custom-components"><a class="header" href="#linking-style-sheets-in-custom-components">Linking style sheets in custom components</a></h4>
<p>For a component to support <code>&lt;w:Style&gt;</code> tags, it simply needs to support a <code>stylesheet : [whack.ds.StyleSheet]</code> parameter.</p>
<pre><code>package com.fun.components {
    //
    public function CustomComponent({
        stylesheet
    }: {
        stylesheet? : [whack.ds.StyleSheet],
    }) {
        //

        return (
            &lt;w:Button&gt;
                &lt;w:Style extend={stylesheet}/&gt;

                click me
            &lt;/w:Button&gt;
        );
    }
}
</code></pre>
<h2 id="specifying-inline-styles"><a class="header" href="#specifying-inline-styles">Specifying inline styles</a></h2>
<p>Use <code>s:n={v}</code> attributes as a shortcut to <code>style={{ ..., n: v }}</code>.</p>
<pre><code>&lt;w:Button s:background="orange"&gt;button1&lt;/w:Button&gt;
</code></pre>
<div style="break-before: page; page-break-before: always;"></div><h1 id="whackds"><a class="header" href="#whackds">WhackDS</a></h1>
<p>WhackDS is a feature of the Whack engine used for extending the closed set of Whack's UI component classes with reactive components. It is functionally similiar to React.js, but its syntax is more similiar to Adobe MXML.</p>
<h2 id="memoization"><a class="header" href="#memoization">Memoization</a></h2>
<p>WhackDS automatically memoizes components, allowing for user customizable parameter/state equality comparison through overriding the <code>[object Object].equals(obj)</code> method. Memoization basically serves the purpose of avoiding re-rendering a component when its parameters do not change.</p>
<p>Just like with React.js, memoizing components has drawbacks such as possibly volatile code regions (such as when internationalizing a product with locale-specific translation strings). In such cases, relying on a WhackDS context will re-render the component when the context changes regardless of whether parameters did or not change.</p>
<p>WhackDS skips re-rendering component if the parent re-renders and the parameters are equals to the previous render; the WhackDS component's own states updating will always re-render it.</p>
<h2 id="style-blocks"><a class="header" href="#style-blocks">Style blocks</a></h2>
<p>WhackDS supports style sheets out of the box. Here is a simple example:</p>
<pre><code>&lt;w:VGroup&gt;
    &lt;w:Style&gt;
        &lt;![CDATA[
            :host {
                background: red;
            }
        ]]&gt;
    &lt;/w:Style&gt;
&lt;/w:VGroup&gt;
</code></pre>
<div style="break-before: page; page-break-before: always;"></div><h1 id="tooling"><a class="header" href="#tooling">Tooling</a></h1>
<p>Building and structuring projects should feel way like Cargo from the Rust language, at least in the Whack engine.</p>
<h2 id="configuration-ease"><a class="header" href="#configuration-ease">Configuration ease</a></h2>
<p>Configuring ShockScript projects is way easier compared to other technologies.</p>
<p>Unlike NPM + TypeScript, you do not have to worry about transpilation or whatsoever when building libraries or applications; not even comparable as ShockScript targets WebAssembly. If you were implementing a library in NPM + TypeScript, you were forced to transpile TypeScript to JavaScript first due to the <code>tsconfig.json</code> file which is ignored from third-party dependencies while compiling, otherwise you would get inconsistent transpilation or compiler errors.</p>
<h2 id="whack-case"><a class="header" href="#whack-case">Whack case</a></h2>
<h3 id="api-documentation"><a class="header" href="#api-documentation">API documentation</a></h3>
<p>API documentation is automatically built for packages that are published to the Whack package registry.</p>
<div style="break-before: page; page-break-before: always;"></div><h1 id="access-control-namespaces"><a class="header" href="#access-control-namespaces">Access control namespaces</a></h1>
<p>ShockScript allows the user to define properties tied to a namespace, which is useful for version control and protection.</p>
<pre><code>package com.company.runner {
    /** @private */
    public namespace runner_internals;
}

package com.company.runner {
    //
    public class Helper {
        /** @private */
        runner_internals const cache : [Number] = [];

        //
        public function track() {
            runner_internals::cache.push(0);
        }
    }
}

package com.company.runner.advanced {
    import com.company.runner.*;

    //
    public function f(helper:Helper) {
        helper.runner_internals::cache.push(10);
    }
}
</code></pre>
<p>Namespaces additionally apply to record types.</p>
<pre><code>package com.business.product {
    /**
     * Flexible version control namespace.
     */
    public namespace Flexible = "http://business.com/product/flexible";
}

package com.business.product {
    /**
     * Judgement version control namespace.
     */
    public namespace Judgement = "http://business.com/product/judgement";
}

package com.business.product {
    /**
     * Pair.
     */
    public type Pair = {
        Flexible::strength : [decimal],
        Judgement::strength : [decimal],
    };
}
</code></pre>
<div style="break-before: page; page-break-before: always;"></div><h1 id="event-model"><a class="header" href="#event-model">Event model</a></h1>
<p>The native <code>EventTarget</code> class is designated for dispatching and listening to events, and actual implementations may use it for implementing a hierarchic DOM event model.</p>
<p>In addition, the <code>IEventTarget</code> interface may be implemented instead of extending the <code>EventTarget</code> class.</p>
<h2 id="implementing-an-event-target"><a class="header" href="#implementing-an-event-target">Implementing an event target</a></h2>
<p>The following program demonstrates implementing a basic <code>EventTarget</code> subclass that is able to emit events:</p>
<pre><code>/**
 * Some event.
 */
[Event(name="act", type="Event")]
/**
 * Some class.
 */
class Actor extends EventTarget {
    /**
     * Some method.
     */
    public function m() {
        this.emit(new Event("act"));
    }
}
</code></pre>
<h2 id="listening-to-an-event"><a class="header" href="#listening-to-an-event">Listening to an event</a></h2>
<p>Subscribing to an event looks as follows:</p>
<pre><code>actor.on("act", function() { trace("acting") });
</code></pre>
<h2 id="implementing-an-event-class"><a class="header" href="#implementing-an-event-class">Implementing an event class</a></h2>
<p><code>Event</code> constructors must always take the event type as the first argument; any other arguments may follow. In the following code the user inherits the <code>Event</code> constructor.</p>
<pre><code>class SomeEvent extends Event {}
</code></pre>
<h2 id="eventtarget-implementation"><a class="header" href="#eventtarget-implementation">EventTarget implementation</a></h2>
<p>It is a rare case for the user to need to implement their own <code>EventTarget</code> class: it may only arise if the user needs <code>EventTarget</code> to work with their own Document Object Model.</p>
<h3 id="emit"><a class="header" href="#emit">emit()</a></h3>
<p>The <code>emit()</code> method is defined as follows:</p>
<pre><code>[Limit(E, eventOf="this", match="object")]
/**
 * Dispatches an event.
 */
public function emit.&lt;E&gt;(e:E):Boolean {
    // code
}
</code></pre>
<p>When the <code>emit()</code> method is used, it will force a <code>new E(...)</code> expression to be a correct <code>Event</code> object construction, by ensuring the first argument identifies a determined event type according to <code>E</code>.</p>
<h3 id="on"><a class="header" href="#on">on()</a></h3>
<p>The <code>on()</code> method is roughly defined as follows:</p>
<pre><code>[Limit(E, eventOf="this", match="type")]
/**
 * Registers an event listener.
 */
public function on.&lt;E&gt;(type:E.name, listener:function(E.type):void) : void {
    //
}
</code></pre>
<p>The third parameter was omitted for clarity.</p>
<div style="break-before: page; page-break-before: always;"></div><h1 id="conditional-compilation"><a class="header" href="#conditional-compilation">Conditional compilation</a></h1>
<pre><code>NAMESPACE::CONSTANT

NAMESPACE::CONSTANT {
    //
}

NAMESPACE::CONSTANT var x
</code></pre>
<div style="break-before: page; page-break-before: always;"></div><h1 id="clonage"><a class="header" href="#clonage">Clonage</a></h1>
<p>The <code>[object Object].clone()</code> implementation clones tuples, arrays and maps structurally; for <code>class</code> instances, the default implementation requires an <em>optional</em> constructor. You may override <code>clone</code> for a custom clonage implementation.</p>
<pre><code>object.clone()
</code></pre>
<div style="break-before: page; page-break-before: always;"></div><h1 id="iteration-capabilities"><a class="header" href="#iteration-capabilities">Iteration capabilities</a></h1>
<p>ShockScript features full object-oriented iteration.</p>
<pre><code>iterator.length()
iterator.some(function(v) v &gt; 0)
iterator.(* &gt; 0) // filter
</code></pre>
<p>The user may override the key and value iterators by implementing the <code>Iterable.&lt;K, V&gt;</code> interface.</p>
<pre><code>class A implements Iterable.&lt;String, Number&gt; {
    /**
     * Iterate keys.
     */
    public function keys():Iterator.&lt;String&gt; {
        for (var i = 0; i &lt; 10; i++) {
            yield i.toString();
        }
    }

    /**
     * Iterate values.
     */
    public function values():Iterator.&lt;Number&gt; {
        for (var i = 0; i &lt; 10; i++) {
            yield i;
        }
    }
}
</code></pre>
<div style="break-before: page; page-break-before: always;"></div><h1 id="environment-variables"><a class="header" href="#environment-variables">Environment variables</a></h1>
<p>Environment variables may be read from the project's <code>.env</code> file using the <code>DotEnv::VAR_NAME</code> expression:</p>
<pre><code>DotEnv::SECRET
</code></pre>
<div style="break-before: page; page-break-before: always;"></div><h1 id="type-matching"><a class="header" href="#type-matching">Type matching</a></h1>
<h2 id="is-operator"><a class="header" href="#is-operator">“is” operator</a></h2>
<pre><code>v is T
</code></pre>
<h2 id="switch-type-statement"><a class="header" href="#switch-type-statement">“switch type” statement</a></h2>
<pre><code>switch type (v) {
    case (regex : RegExp) {
        trace("a regex");
    }
    case ([x, y] : [Number, Number]) {
        trace("a tuple of double");
    }
    default {
        trace("any other");
    }
}
</code></pre>
<div style="break-before: page; page-break-before: always;"></div><h1 id="scope"><a class="header" href="#scope">Scope</a></h1>
<p>This document specifies the syntax, semantics, execution and global objects of the ShockScript language.</p>
<div style="break-before: page; page-break-before: always;"></div><h1 id="definitions"><a class="header" href="#definitions">Definitions</a></h1>
<h2 id="code-point"><a class="header" href="#code-point">Code Point</a></h2>
<p>A Code Point as specified by the Unicode standard.</p>
<h2 id="scalar-value"><a class="header" href="#scalar-value">Scalar Value</a></h2>
<p>A Scalar Value as specified by the Unicode standard.</p>
<h2 id="required-function"><a class="header" href="#required-function">Required function</a></h2>
<p>A function that contains at least one required parameter.</p>
<h2 id="required-method"><a class="header" href="#required-method">Required method</a></h2>
<p>A method that contains at least one required parameter.</p>
<h2 id="required-constructor"><a class="header" href="#required-constructor">Required constructor</a></h2>
<p>A constructor that contains at least one required parameter.</p>
<div style="break-before: page; page-break-before: always;"></div><h1 id="notational-conventions"><a class="header" href="#notational-conventions">Notational conventions</a></h1>
<h2 id="syntactic-and-lexical-grammars"><a class="header" href="#syntactic-and-lexical-grammars">Syntactic and lexical grammars</a></h2>
<p>This document uses the following notation to define one or more productions of a nonterminal of the syntactic grammar:</p>
<ul>
    <i>Symbol</i> :
    <ul>
        <i>Production1</i> <i>Symbol1</i><br>
        <i>ProductionN</i>
    </ul>
</ul>
<p>This document uses double colon (::) notation to define productions of a nonterminal of the lexical grammar:</p>
<ul>
    <i>Symbol</i> ::
    <ul>
        <b>terminal</b>
    </ul>
</ul>
<p>The <sub>opt</sub> subscript is used to indicate that a nonterminal symbol is optional.</p>
<ul>
    <i>Symbol</i> ::
    <ul>
        <i>Symbol1</i><sub>opt</sub>
    </ul>
</ul>
<p>A bracketed clause or predicate may appear between the rules of a production, such as in:</p>
<ul>
    <i>Symbol</i> ::
    <ul>
        [lookahead ∈ { <b>0</b> }] <i>Symbol1</i><br>
        [lookahead ∉ { <b>default</b> }] <i>Symbol2</i><br>
        <i>SourceCharacters</i> [but no embedded <b>&lt;!&#x5b;CDATA&#x5b;</b>]
    </ul>
</ul>
<p>The «empty» clause is matched by the grammar where other rules do not match otherwise.</p>
<ul>
    <i>Symbol</i> :
    <ul>
        «empty»
    </ul>
</ul>
<p>Braces subscripts are used to quantify a rule:</p>
<ul>
<li><i>Symbol</i><sub>{4}</sub> — Four of <i>Symbol</i></li>
<li><i>Symbol</i><sub>{2,}</sub> — At least two of <i>Symbol</i></li>
<li><i>Symbol</i><sub>{1,4}</sub> — One to four of <i>Symbol</i></li>
</ul>
<div style="break-before: page; page-break-before: always;"></div><h1 id="types"><a class="header" href="#types">Types</a></h1>
<p>This section describes the data types and certain type expressions available in ShockScript.</p>
<div style="break-before: page; page-break-before: always;"></div><h1 id="wildcard-type"><a class="header" href="#wildcard-type">Wildcard type</a></h1>
<p>The <code>*</code> type is dynamically typed and consists of all possible values in other types.</p>
<div style="break-before: page; page-break-before: always;"></div><h1 id="void-type"><a class="header" href="#void-type">void type</a></h1>
<p>The <code>void</code> type consists of the <code>undefined</code> value.</p>
<div style="break-before: page; page-break-before: always;"></div><h1 id="null-type"><a class="header" href="#null-type">null type</a></h1>
<p>The <code>null</code> type consists of the <code>null</code> value.</p>
<div style="break-before: page; page-break-before: always;"></div><h1 id="string-type-1"><a class="header" href="#string-type-1">String type</a></h1>
<p>The <code>String</code> type represents an UTF-8 encoded character sequence.</p>
<blockquote>
<p><strong>Note</strong>: the <code>.length</code> property of a String equals the byte total, and the <code>.chars().length()</code> method of a String equals the Code Point total.</p>
</blockquote>
<h2 id="nullability-1"><a class="header" href="#nullability-1">Nullability</a></h2>
<p>Even though it is a primitive type, the <code>String</code> type may be assigned <code>null</code> to indicate absence of value, as it is a reference type.</p>
<blockquote>
<p><strong>Note</strong>: <code>null</code> and <code>""</code> are two different values. You may test for both through using <code>String</code> as a falsy condition.</p>
</blockquote>
<div style="break-before: page; page-break-before: always;"></div><h1 id="boolean-type"><a class="header" href="#boolean-type">Boolean type</a></h1>
<p>The <code>Boolean</code> type consists of the values <code>false</code> and <code>true</code>.</p>
<div style="break-before: page; page-break-before: always;"></div><h1 id="number-type"><a class="header" href="#number-type">Number type</a></h1>
<p>The <code>Number</code> type represents an IEEE 754 double-precision floating point.</p>
<div style="break-before: page; page-break-before: always;"></div><h1 id="bigint-type"><a class="header" href="#bigint-type">BigInt type</a></h1>
<p>The <code>BigInt</code> type represents an arbitrary range integer.</p>
<div style="break-before: page; page-break-before: always;"></div><h1 id="float-type"><a class="header" href="#float-type">float type</a></h1>
<p>The <code>float</code> type represents an IEEE 754 single-precision floating point.</p>
<div style="break-before: page; page-break-before: always;"></div><h1 id="decimal-type"><a class="header" href="#decimal-type">decimal type</a></h1>
<p>The <code>decimal</code> type represents a 128 bit decimal number.</p>
<div style="break-before: page; page-break-before: always;"></div><h1 id="int-type"><a class="header" href="#int-type">int type</a></h1>
<p>The <code>int</code> type represents a signed 32-bit integer.</p>
<div style="break-before: page; page-break-before: always;"></div><h1 id="uint-type"><a class="header" href="#uint-type">uint type</a></h1>
<p>The <code>uint</code> type represents an unsigned 32-bit integer.</p>
<div style="break-before: page; page-break-before: always;"></div><h1 id="array-type"><a class="header" href="#array-type">Array type</a></h1>
<p>The <code>Array.&lt;T&gt;</code> type, abbreviated <code>[T]</code>, represents a growable list of elements.</p>
<h2 id="numeric-optimization"><a class="header" href="#numeric-optimization">Numeric optimization</a></h2>
<p><code>[T]</code> is optimized for when <code>T</code> is a number type; for instance, <code>[uint]</code> will use a growable buffer optimized specifically for 32-bit unsigned integers.</p>
<div style="break-before: page; page-break-before: always;"></div><h1 id="map-type"><a class="header" href="#map-type">Map type</a></h1>
<p>The <code>Map.&lt;K, V&gt;</code> type represents a hash map.</p>
<pre><code>Map.&lt;K, V&gt;
</code></pre>
<blockquote>
<p><strong>Note:</strong> Property access on a <code>Map</code> equals data access. Method call on a <code>Map</code> equals a <code>Map</code> method use.</p>
</blockquote>
<h2 id="instance-usage"><a class="header" href="#instance-usage">Instance usage</a></h2>
<pre><code>const map = new Map.&lt;String, Number&gt;();

// x=10
map.x = 10;

const fns = new Map.&lt;String, Function&gt;();

// m=function
fns.m = function() 10;

// m()
trace((fns.m)());
</code></pre>
<div style="break-before: page; page-break-before: always;"></div><h1 id="tuple-types"><a class="header" href="#tuple-types">Tuple types</a></h1>
<p>Tuple types, of the form <code>[T1, T2, ...TN]</code>, are immutable sequences consisting of known element types at compile time. A tuple type contains at least two elements.</p>
<pre><code>[Boolean, float]
</code></pre>
<div style="break-before: page; page-break-before: always;"></div><h1 id="function-types"><a class="header" href="#function-types">Function types</a></h1>
<p>Structural function types inherit from the <code>Function</code> class, taking the form <code>function(...) : T</code>.</p>
<pre><code>function(T1, T=, ...[T]):T
</code></pre>
<p>A structural function type may specify:</p>
<ul>
<li>zero or more required parameters (<code>T</code>) followed by</li>
<li>zero or more optional parameters (<code>T=</code>) followed by</li>
<li>a rest parameter (<code>...[T]</code>),</li>
<li>and a result type.</li>
</ul>
<div style="break-before: page; page-break-before: always;"></div><h1 id="record-types"><a class="header" href="#record-types">Record types</a></h1>
<p>Record types <code>{ ... }</code> are simple property records. Record types are memory-efficient in cost of a hash-map-like field access.</p>
<blockquote>
<p><strong>Note</strong>: The decision for having record types compiling into hash-map structures is because these types use to contain many fields, for instance, in WhackDS components and in operations requiring a large number of options.</p>
</blockquote>
<pre><code>type N1 = { x : decimal, y : decimal };

type N2 = {
    /** x */
    x:Number,

    /** y */
    y?:Boolean,
};
</code></pre>
<blockquote>
<p><strong>Note</strong>: Record types do not match with types structurally unlike in structural-type-first languages. They are simply structures the user may express inline.</p>
</blockquote>
<h2 id="version-control"><a class="header" href="#version-control">Version control</a></h2>
<p>Fields of a record type may be tied to a namespace, which is useful for version control.</p>
<pre><code>package com.business.product {
    /**
     * Flexible version control namespace.
     */
    public namespace Flexible = "http://business.com/product/flexible";
}

package com.business.product {
    /**
     * Judgement version control namespace.
     */
    public namespace Judgement = "http://business.com/product/judgement";
}

package com.business.product {
    /**
     * Pair.
     */
    public type Pair = {
        Flexible::strength : [decimal],
        Judgement::strength : [decimal],
    };
}
</code></pre>
<h2 id="field-omission"><a class="header" href="#field-omission">Field omission</a></h2>
<p>All fields are required unless they contain <code>undefined</code> or <code>null</code>. A field such as <code>x?:T</code> is equivalent to <code>x:(void, T)</code>.</p>
<h2 id="field-order"><a class="header" href="#field-order">Field order</a></h2>
<p>Due to sensitive field order, record types with equivalent fields but in different orders will be incompatible.</p>
<h2 id="writing-shockdoc-comments"><a class="header" href="#writing-shockdoc-comments">Writing ShockDoc comments</a></h2>
<p>Fields may have a preceding ShockDoc comment, as in:</p>
<pre><code>type R = {
    /**
     * Comment.
     */
    x : Number,
};
</code></pre>
<h2 id="compatibility"><a class="header" href="#compatibility">Compatibility</a></h2>
<p>Two record types are compatible only if either a) one is used as a subset of another or b) fields are equivalent and appear in the same order.</p>
<h2 id="rest"><a class="header" href="#rest">Rest</a></h2>
<p>One trailing <code>...rest</code> component may appear in a record, where <code>rest</code> must be another record type. The resulting type is a subtype of <code>rest</code> and properties <strong>must not</strong> collide.</p>
<pre><code>// A
type A = { x:Number };
// B &lt; A
type B = { y:Number, ...A };
</code></pre>
<div style="break-before: page; page-break-before: always;"></div><h1 id="union-types"><a class="header" href="#union-types">Union types</a></h1>
<p>The structural union type, written <code>(m1, m2, ...mN)</code>, consists of two or more non-union member types containing all possible values of the member types.</p>
<pre><code>(decimal, String)
</code></pre>
<h2 id="restrictions"><a class="header" href="#restrictions">Restrictions</a></h2>
<ul>
<li>Unions never contain the <code>*</code> type.</li>
<li>Unions contain two or more members.</li>
</ul>
<h2 id="default-value"><a class="header" href="#default-value">Default value</a></h2>
<p>The default value of an union type is determined as follows:</p>
<ol>
<li>If it contains <code>void</code>, then <code>undefined</code>.</li>
<li>If it contains <code>null</code>, then <code>null</code>.</li>
<li>No default value.</li>
</ol>
<h2 id="nullability-2"><a class="header" href="#nullability-2">Nullability</a></h2>
<p>The following shorthands are available for nullability:</p>
<ul>
<li><code>T?</code> or <code>?T</code> is equivalent to <code>(null, T)</code>.</li>
<li><code>T!</code> removes <code>null</code> and/or <code>void</code> from <code>T</code>.</li>
</ul>
<div style="break-before: page; page-break-before: always;"></div><h1 id="object-type"><a class="header" href="#object-type">Object type</a></h1>
<p>All types but { <code>void</code>, <code>null</code>, <code>uint</code>, <code>int</code>, <code>float</code>, <code>Number</code>, <code>decimal</code>, <code>BigInt</code>, <code>Boolean</code> } represent referenceable objects, which are nullable by default. The <code>Object</code> class is inherited by all types but { <code>*</code>, <code>void</code>, <code>null</code>, union }.</p>
<blockquote>
<p><strong>Note</strong>: When it is necessary to obtain the constructor of an object, use:</p>
<pre><code>obj.Reflect::class()
</code></pre>
</blockquote><div style="break-before: page; page-break-before: always;"></div><h1 id="this-type"><a class="header" href="#this-type">This type</a></h1>
<p>The <code>this</code> type expression may be used to match the <code>this</code> literal's type, which changes across subclasses.</p>
<pre><code>class A {
    function chainable():this (this);
}

class B extends A {}

const obj = new B();
obj.chainable() // known as B
</code></pre>
<div style="break-before: page; page-break-before: always;"></div><h1 id="conversions"><a class="header" href="#conversions">Conversions</a></h1>
<p>This section describes which type conversions are available.</p>
<p>Explicit conversions may occur as either <code>T(v)</code> (strict conversion) or <code>v as T</code> (optional conversion). The behavior of the call operator over a type may not always be a conversion depending on if <code>T</code> implements the static <code>shock_proxy::call()</code> method.</p>
<pre><code>T(v)       // failure throws a TypeError
v as T     // failure returns a default value
</code></pre>
<h2 id="constant-coercions"><a class="header" href="#constant-coercions">Constant coercions</a></h2>
<p>Constant coercions occur implicitly both at compile-time and runtime, converting a constant into another constant.</p>
<div class="table-wrapper"><table><thead><tr><th>Kind</th><th>Result</th></tr></thead><tbody>
<tr><td><code>undefined</code> to flag enumeration</td><td>Interned instance whose value is zero (<strong>0</strong>).</td></tr>
<tr><td><code>null</code> to flag enumeration</td><td>Interned instance whose value is zero (<strong>0</strong>).</td></tr>
<tr><td><code>undefined</code> to <code>T</code> containing both <code>undefined</code> and <code>null</code></td><td><code>undefined</code></td></tr>
<tr><td><code>undefined</code> to <code>T</code> containing <code>undefined</code> and no <code>null</code></td><td><code>undefined</code></td></tr>
<tr><td><code>undefined</code> to <code>T</code> containing <code>null</code> and no <code>undefined</code></td><td><code>null</code></td></tr>
<tr><td><code>null</code> to <code>T</code> containing <code>undefined</code> but not <code>null</code></td><td><code>undefined</code></td></tr>
<tr><td><code>null</code> to <code>T</code> containing <code>null</code> but not <code>undefined</code></td><td><code>null</code></td></tr>
<tr><td><code>null</code> to <code>T</code> containing both <code>undefined</code> or <code>null</code></td><td><code>null</code></td></tr>
<tr><td>Numeric constant to <code>*</code> or <code>Object</code></td><td>Equivalent constant of the target type.</td></tr>
<tr><td>String constant to <code>*</code> or <code>Object</code> or union containing <code>String</code></td><td>Equivalent constant of the target type.</td></tr>
<tr><td>Boolean constant to <code>*</code> or <code>Object</code> or union containing <code>Boolean</code></td><td>Equivalent constant of the target type.</td></tr>
<tr><td>Namespace constant to <code>*</code> or <code>Object</code> or union containing <code>Namespace</code></td><td>Equivalent constant of the target type.</td></tr>
<tr><td>Type constant to <code>*</code> or <code>Object</code> or union containing <code>Class</code></td><td>Equivalent constant of the target type.</td></tr>
<tr><td>Numeric constant to another compatible numeric type</td><td>Numeric constant with value coerced to target type.</td></tr>
<tr><td>Numeric constant to union containing at least one compatible numeric type</td><td>Numeric constant of the target type containing value coerced to the containing numeric type, preferring the <em>same</em> numeric type or otherwise the first numeric type found.</td></tr>
<tr><td><code>NaN</code> to <code>float</code></td><td><code>NaN</code></td></tr>
<tr><td><code>-Infinity</code> to <code>float</code></td><td><code>-Infinity</code></td></tr>
<tr><td><code>+Infinity</code> to <code>float</code></td><td><code>+Infinity</code></td></tr>
</tbody></table>
</div>
<h2 id="implicit-coercion"><a class="header" href="#implicit-coercion">Implicit coercion</a></h2>
<p>Implicit coercions occur implicitly both at compile-time and runtime, after trying a constant coercion.</p>
<div class="table-wrapper"><table><thead><tr><th>Kind</th><th>Result</th></tr></thead><tbody>
<tr><td>From <code>*</code></td><td></td></tr>
<tr><td>To <code>*</code></td><td></td></tr>
<tr><td>From numeric type to compatible numeric type</td><td></td></tr>
<tr><td>To covariant (includes base classes, implemented interfaces, unions and inherited record type)</td><td></td></tr>
<tr><td>From union to compatible union</td><td></td></tr>
<tr><td>From union member to union</td><td></td></tr>
<tr><td>From structural function type to another compatible function type</td><td></td></tr>
</tbody></table>
</div>
<blockquote>
<p><strong>Note</strong>: <code>interface</code> types inherit <code>Object</code>.</p>
</blockquote>
<h2 id="explicit-conversions"><a class="header" href="#explicit-conversions">Explicit conversions</a></h2>
<p>Explicit conversions occur when resolving <code>v as T</code> or <code>T(v)</code>, after trying an implicit coercion.</p>
<div class="table-wrapper"><table><thead><tr><th>Kind</th><th>Result</th></tr></thead><tbody>
<tr><td>To contravariant (from <code>interface</code> to <code>interface</code> subtype, from <code>class</code> to subclass, or record type subtype)</td><td></td></tr>
<tr><td>To union member</td><td></td></tr>
<tr><td>From <code>*</code> or <code>Object</code> to <code>interface</code></td><td></td></tr>
<tr><td>To another <code>[T]</code> type</td><td>An array filtering out incompatible elements.</td></tr>
<tr><td><code>String</code> to enumeration</td><td>Identification of an enumeration variant by its <code>String</code> name.</td></tr>
<tr><td>Number to enumeration (using the same numeric type)</td><td>For regular enumerations, identifies a variant by its numeric value. For flag enumerations, identifies variant bits.</td></tr>
<tr><td>To <code>String</code></td><td>For <code>undefined</code>, returns <code>"undefined"</code>; for <code>null</code>, returns <code>"null"</code>; for other types, invokes <code>toString()</code>.</td></tr>
<tr><td>To <code>Boolean</code></td><td>Evaluates truthy value.</td></tr>
<tr><td>To <code>Number</code></td><td>Forced conversion to double-precision floating point.</td></tr>
<tr><td>To <code>float</code></td><td>Forced conversion to single-precision floating point.</td></tr>
<tr><td>To <code>decimal</code></td><td>Forced conversion to 128-bit decimal number.</td></tr>
<tr><td>To <code>int</code></td><td>Forced conversion to 32-bit signed integer.</td></tr>
<tr><td>To <code>uint</code></td><td>Forced conversion to 32-bit unsigned uninteger.</td></tr>
<tr><td>To <code>BigInt</code></td><td>Forced conversion to an arbitrary range integer.</td></tr>
<tr><td>Record type into equivalent record type of non-uniform field order</td><td></td></tr>
<tr><td>From type parameter</td><td></td></tr>
</tbody></table>
</div>
<blockquote>
<p><strong>Note</strong>: <code>interface</code> types inherit <code>Object</code>.</p>
</blockquote>
<div style="break-before: page; page-break-before: always;"></div><h1 id="property-lookup"><a class="header" href="#property-lookup">Property lookup</a></h1>
<h2 id="lookupkey"><a class="header" href="#lookupkey">LookupKey</a></h2>
<p><em>LookupKey</em> is either <em>LocalName</em>(<em>name</em>) or <em>Computed</em>(<em>value</em>).</p>
<h3 id="lookupkeyvalue"><a class="header" href="#lookupkeyvalue">LookupKey.Value</a></h3>
<p><em>LookupKey</em>.Value returns:</p>
<ul>
<li>For <em>LocalName</em>(<em>name</em>), a <em>StringConstant</em> equivalent to <em>name</em> or defer if <code>String</code> is unresolved.</li>
<li>For <em>Computed</em>(<em>value</em>), <em>value</em>.</li>
</ul>
<h3 id="lookupkeytype"><a class="header" href="#lookupkeytype">LookupKey.Type</a></h3>
<p><em>LookupKey</em>.Type returns:</p>
<ul>
<li>For <em>LocalName</em>(<em>name</em>), the <code>String</code> type or defer.</li>
<li>For <em>Computed</em>(<em>value</em>), the static type of <em>value</em> or defer.</li>
</ul>
<h3 id="lookupkeydouble"><a class="header" href="#lookupkeydouble">LookupKey.Double</a></h3>
<p><em>LookupKey</em>.Double returns:</p>
<ul>
<li>For <em>LocalName</em>(<em>name</em>), undefined.</li>
<li>For <em>Computed</em>(<em>value</em>), <em>value</em> is <em>NumberConstant</em>(<em>v</em>) ? force convert <em>v</em> to a <code>Number</code> : undefined.</li>
</ul>
<h2 id="propertylookup"><a class="header" href="#propertylookup">PropertyLookup()</a></h2>
<p><em>PropertyLookup</em>(<em>base</em>, <em>openNsSet</em>, <em>qual</em>, <em>key</em> as <em>LookupKey</em>, <em>followedByCall</em> as <code>Boolean</code>, <em>fixed</em> as <code>Boolean</code>) takes the following steps in order, where <em>fixed</em> allows forcing access to a fixture property on dynamic types (used by the <code>&lt;?fixed={}?&gt;</code> expression):</p>
<ul>
<li>If <em>base</em> is invalidation
<ul>
<li>Return invalidation</li>
</ul>
</li>
<li>Let <em>localName</em> = <em>key</em> is <em>LocalName</em>(<em>name</em>) ? <em>name</em> : undefined</li>
<li>Let <em>doubleKey</em> = <em>key</em>.Double</li>
<li>If <em>base</em> is a <em>TypeConstant</em>(<em>type</em>)
<ul>
<li><em>base</em> = <em>type</em></li>
</ul>
</li>
<li>Else if <em>base</em> is a <em>FixtureReferenceValue</em> and <em>base</em>.Property is a type
<ul>
<li><em>base</em> = <em>base</em>.Property</li>
</ul>
</li>
<li>If <em>base</em> is a class
<ul>
<li>If <em>localName</em> is undefined or (<em>qual</em> is specified and <em>qual</em> is not a namespace nor a <em>NamespaceConstant</em>)
<ul>
<li>Return <em>StaticDynamicReferenceValue</em>(<em>base</em>, <em>qual</em>, <em>k</em>.Value)</li>
</ul>
</li>
<li>For each descending <em>class</em> in <em>base</em> hierarchy
<ul>
<li>Defer if <em>class</em> is unresolved.</li>
<li>Let <em>r</em> = <em>GetQNameInNsSetOrAnyPublicNs</em>(<em>class</em> static properties, <em>openNsSet</em>, <em>qual</em>, <em>localName</em>)</li>
<li>If <em>r</em> != undefined
<ul>
<li>Mark <em>r</em> as used.</li>
<li>Let <em>r</em> = <em>r</em>.ResolveAlias()</li>
<li>Defer if <em>r</em> property's static type is unresolved.</li>
<li>Return <em>r</em>.Wrap()</li>
</ul>
</li>
</ul>
</li>
<li>Return undefined</li>
</ul>
</li>
<li>If <em>base</em> is an interface
<ul>
<li>Return undefined</li>
</ul>
</li>
<li>If <em>base</em> is a value
<ul>
<li>Let <em>baseType</em> = static type of <em>base</em> or defer</li>
<li>If <em>baseType</em> is invalid
<ul>
<li>Return invalid</li>
</ul>
</li>
<li><em>baseType</em> = <em>baseType</em>.ResolveAlias()</li>
<li>If (<em>followedByCall</em> == false and <em>fixed</em> == false) and <em>baseType</em> defines an instance method <code>shock_proxy::get</code> (possibly a multi method)
<ul>
<li>Let <em>foundRegularProperty</em> = false</li>
<li>For each <code>shock_proxy::get(k:K):V</code> method
<ul>
<li>If <em>qual</em> != undefined
<ul>
<li>If <em>K</em> == <code>*</code> or <em>K</em> == (<code>Object</code> or defer) or <em>K</em> == (<code>QName</code> or defer) or <em>K</em> ?union contains (<code>QName</code> or defer)
<ul>
<li>Return <em>KeyValuePairReferenceValue</em>(<em>base</em>, <em>proxy method</em>, <em>qual</em> as a <code>Namespace</code> object, <em>key</em>.Value coerced to (<code>String</code> or defer))</li>
</ul>
</li>
<li>Continue loop</li>
</ul>
</li>
<li>If <em>key</em>.Value is a (<code>String</code> or defer) value and (<em>K</em> == (<code>QName</code> or defer) or (<em>K</em> ?union does not contain <code>String</code> and <em>K</em> union contains <code>QName</code>))
<ul>
<li>Return <em>KeyValuePairReferenceValue</em>(<em>base</em>, <em>proxy method</em>, undefined, <em>key</em>.Value)</li>
</ul>
</li>
<li>If <em>K</em> == <code>*</code> or <em>K</em> == (<code>Object</code> or defer) or <em>K</em> == (<code>String</code> or defer) or <em>K</em> == (<code>QName</code> or defer) or (<em>K</em> ?union contains <code>String</code> or <em>K</em> union contains <code>QName</code>)
<ul>
<li><em>foundRegularProperty</em> = true</li>
</ul>
</li>
<li>If (static type of <em>key</em>.Value or defer) fails on implicit coercion to <em>K</em>
<ul>
<li>Continue loop</li>
</ul>
</li>
<li>Return <em>KeyValuePairReferenceValue</em>(<em>base</em>, <em>proxy method</em>, undefined, <em>key</em>.Value implicitly coerced to <em>K</em>)</li>
</ul>
</li>
<li>If (static type of <em>key</em>.Value or defer) != (<code>String</code> or defer) or <em>foundRegularProperty</em>
<ul>
<li>Throw a verify error</li>
</ul>
</li>
</ul>
</li>
<li>Let <em>hasKnownNs</em> = <em>qual</em> == undefined or (<em>qual</em> is a namespace or <em>NamespaceConstant</em>)</li>
<li>If <em>localName</em> == undefined
<ul>
<li>If <em>doubleKey</em> != undefined and <em>baseType</em> is a tuple
<ul>
<li>Let <em>i</em> = <em>doubleKey</em> coercion to integer</li>
<li>If <em>i</em> &lt; 0 or <em>i</em> &gt;= <em>baseType</em>.ElementTypes.Length
<ul>
<li>Throw a verify error</li>
</ul>
</li>
<li>Return <em>TupleReferenceValue</em>(<em>base</em>, <em>i</em>)</li>
</ul>
</li>
<li>Return <em>DynamicReferenceValue</em>(<em>base</em>, <em>qual</em>, <em>key</em>.Value, <em>followedByCall</em>, <em>fixed</em>)</li>
</ul>
</li>
<li>If <em>baseType</em> == <code>*</code>
<ul>
<li>Return <em>DynamicReferenceValue</em>(<em>base</em>, <em>qual</em>, <em>key</em>.Value, <em>followedByCall</em>, <em>fixed</em>)</li>
</ul>
</li>
<li>If <em>baseType</em> is a class
<ul>
<li>For each descending <em>class</em> in <em>baseType</em> hierarchy
<ul>
<li>Defer if <em>class</em> is unresolved</li>
<li>Let <em>prop</em> = <em>GetQNameInNsSetOrAnyPublicNs</em>(<em>class</em> prototype properties, <em>openNsSet</em>, <em>qual</em>, <em>localName</em>)</li>
<li>If <em>prop</em> != undefined
<ul>
<li>Mark <em>prop</em> as used</li>
<li><em>prop</em> = <em>prop</em>.ResolveAlias()</li>
<li>Call <em>prop</em>.Defer() (<em>if about to defer, implementation may report the cause as unresolved expression in a location</em>)</li>
<li>If <em>prop</em> is a namespace or <em>NamespaceConstant</em>
<ul>
<li>Return <em>NamespaceConstant</em>(<em>prop</em>) if <em>prop</em> is a namespace, or otherwise <em>prop</em> as is</li>
</ul>
</li>
<li>Return <em>InstanceReferenceValue</em>(<em>base</em>, <em>prop</em>)</li>
</ul>
</li>
</ul>
</li>
<li>For implemented interfaces of <em>baseType</em>
<ul>
<li><em>Lookup method (step required for optional methods)</em></li>
</ul>
</li>
</ul>
</li>
<li>Else if <em>baseType</em> is an interface
<ul>
<li>For each descending <em>itrfc</em> in <em>baseType</em> hierarchy
<ul>
<li>Defer if <em>itrfc</em> is unresolved</li>
<li>Let <em>prop</em> = <em>GetQNameInNsSetOrAnyPublicNs</em>(<em>itrfc</em> prototype properties, <em>openNsSet</em>, <em>qual</em>, <em>localName</em>)</li>
<li>If <em>prop</em> != undefined
<ul>
<li>Mark <em>prop</em> as used</li>
<li><em>prop</em> = <em>prop</em>.ResolveAlias()</li>
<li>Call <em>prop</em>.Defer() (<em>if about to defer, implementation may report the cause as unresolved expression in a location</em>)</li>
<li>Return <em>InstanceReferenceValue</em>(<em>base</em>, <em>prop</em>)</li>
</ul>
</li>
</ul>
</li>
<li><em>Lookup for the</em> <code>Object</code> <em>instance definitions</em></li>
</ul>
</li>
<li>Return undefined.</li>
</ul>
</li>
<li>If <em>base</em> is a <code>package</code>
<ul>
<li>If <em>localName</em> is undefined or (<em>qual</em> is specified and <em>qual</em> is not a namespace nor a <em>NamespaceConstant</em>)
<ul>
<li>Throw a verify error</li>
</ul>
</li>
<li>Let r = undefined</li>
<li>Let <em>prop</em> = <em>GetQNameInNsSetOrAnyPublicNs</em>(<em>base</em> properties, <em>openNsSet</em>, <em>qual</em>, <em>localName</em>)</li>
<li>If <em>prop</em> != undefined
<ul>
<li>Mark <em>r</em> as used.</li>
<li><em>prop</em> = <em>prop</em>.ResolveAlias()</li>
<li>Call <em>prop</em>.Defer() (<em>if about to defer, implementation may report the cause as unresolved expression in a location</em>)</li>
<li><em>r</em> = <em>prop</em>.Wrap()</li>
</ul>
</li>
<li>Return r</li>
</ul>
</li>
<li>If <em>base</em> is a type parameter with a <code>Limit(..., eventOf="...", match="type")</code> constraint
<ul>
<li>If <em>localName</em> is undefined or (<em>qual</em> is specified)
<ul>
<li>Return undefined.</li>
</ul>
</li>
<li>If <em>localName</em> = <strong>name</strong>
<ul>
<li>Return <em>EventNameType</em>(<em>base</em> type parameter).Wrap()</li>
</ul>
</li>
<li>If <em>localName</em> = <strong>type</strong>
<ul>
<li>Return <em>EventTypeType</em>(a previously introduced <em>EventNameType</em>).Wrap().</li>
</ul>
</li>
<li>Return undefined.</li>
</ul>
</li>
<li>Return undefined.</li>
</ul>
<blockquote>
<p><strong>Note</strong>: entity.Wrap() wraps entities into values. For instance, wrapping a variable into a property reference, where it belongs to a package, will produce a <em>PackageReferenceValue</em>.</p>
</blockquote>
<blockquote>
<p><strong>Note</strong>: entity.Defer() defers if an entity is unresolved or if a direct compound is unresolved.</p>
</blockquote>
<h2 id="inscopelookup"><a class="header" href="#inscopelookup">InScopeLookup()</a></h2>
<p><em>InScopeLookup</em>(<em>scope</em>, <em>qual</em>, <em>key</em> as <em>LookupKey</em>, <em>followedByCall</em> as <code>Boolean</code>, <em>fixed</em> as <code>Boolean</code>) takes the following steps in order:</p>
<blockquote>
<p><strong>Note</strong>: Content lacking.</p>
</blockquote>
<div style="break-before: page; page-break-before: always;"></div><h1 id="packages"><a class="header" href="#packages">Packages</a></h1>
<p>A package consists of a ascending domain name, a set of properties and two namespaces, <code>public</code> and <code>internal</code>.</p>
<p>A package <code>com.business.enum</code> is expressed as:</p>
<pre><code>package com.business.enum {
    //
}
</code></pre>
<blockquote>
<p><strong>Note</strong>: One common convention is for packages to use a prefix domain (one of ( <code>com</code>, <code>net</code>, <code>org</code>, <code>me</code> )); alternatively an user may use a prefixless domain name (such as <code>skia</code> rather than <code>com.google.skia</code>). The <code>me</code> prefix is used for personal content and the rest for companies, organizations and groups.</p>
</blockquote>
<p>The user defines properties under the package inside the <code>package</code> block, as in:</p>
<pre><code>package f.q {
    public function f() {}
}
</code></pre>
<h2 id="top-level-package"><a class="header" href="#top-level-package">Top-level package</a></h2>
<p>The top-level package, which defines global properties, is equivalent to:</p>
<pre><code>package {
    //
}
</code></pre>
<p>When a global name is shadowed, the user may use the special <code>global</code> namespace to lookup a global name:</p>
<pre><code>Math
    // or
global::Math
</code></pre>
<h2 id="name-shadowing"><a class="header" href="#name-shadowing">Name shadowing</a></h2>
<p>It is possible to fully qualify a name in an expression using a package and one of its items, shadowing any other variables.</p>
<pre><code>import org.colourful.color.types.Color;
var com = 0;
trace( org.colourful.color.types.Color(0x10_00_00) );
trace( Color(0x10_00_00) );
</code></pre>
<h2 id="readme"><a class="header" href="#readme">ReadMe</a></h2>
<p>A directory identifying a package relative to a source path may contain a README file (either <code>README</code> or <code>README.md</code>) written as Markdown text, which serves as a means to attach documentation to the package.</p>
<h2 id="package-single-import"><a class="header" href="#package-single-import">Package single import</a></h2>
<p>A package single import is contributed to the lexical scope for the following directive:</p>
<pre><code>import f.q.x;
</code></pre>
<h2 id="package-wildcard-import"><a class="header" href="#package-wildcard-import">Package wildcard import</a></h2>
<p>A package wildcard import is aliased for the following directive:</p>
<pre><code>import q = com.business.quantum.*;
</code></pre>
<p>Then <code>q</code> may be used as a qualifier to resolve to a name in the <code>com.business.quantum.*</code> package (excluding subpackages).</p>
<pre><code>q::x
</code></pre>
<p>For the following directive, the package wildcard import is contributed to the lexical scope:</p>
<pre><code>import com.business.quantum.*;
</code></pre>
<h2 id="source-path"><a class="header" href="#source-path">Source path</a></h2>
<ul>
<li>A package definition must contain exactly one definition item, and its name must match the source path.</li>
<li>A source file must consist of exactly one package definition.</li>
</ul>
<div style="break-before: page; page-break-before: always;"></div><h1 id="namespaces"><a class="header" href="#namespaces">Namespaces</a></h1>
<p>Names are three-dimensional, consisting of a namespace (the <em>qualifier</em>) and a local name. The <code>::</code> punctuator is used in qualified identifiers for using a namespace prefix and a local name, as in:</p>
<pre><code>q::n
o.q::n
</code></pre>
<p>Namespaces appear as optional access modifiers in annotatable definitions, as in:</p>
<pre><code>special_properties var acc:decimal = 0;
</code></pre>
<p>There are <em>reserved</em> namespaces and <em>user</em> namespaces.</p>
<h2 id="reserved-namespaces"><a class="header" href="#reserved-namespaces">Reserved namespaces</a></h2>
<p>Reserved namespaces are created implicitly by the language:</p>
<ul>
<li><code>public</code></li>
<li><code>internal</code></li>
<li><code>protected</code></li>
<li><code>private</code></li>
<li><code>static protected</code></li>
</ul>
<p>They are tied to a parent (such as a package, a class or a scope).</p>
<p>A <code>namespace</code> definition that omits the URI creates an <code>internal</code> namespace:</p>
<pre><code>namespace special_properties;
</code></pre>
<h2 id="user-namespaces"><a class="header" href="#user-namespaces">User namespaces</a></h2>
<p>User namespaces are identified by an URI.</p>
<pre><code>namespace observer_internals = "http://observer.net/internals";
</code></pre>
<div style="break-before: page; page-break-before: always;"></div><h1 id="classes"><a class="header" href="#classes">Classes</a></h1>
<p>A class is an inheritable user-defined type that may be used to create objects.</p>
<pre><code>class C1 {
    //
}
const obj = new C1();
</code></pre>
<h2 id="inner-namespaces"><a class="header" href="#inner-namespaces">Inner namespaces</a></h2>
<p>A class owns three namespaces:</p>
<ul>
<li><code>private</code></li>
<li><code>protected</code></li>
<li><code>static protected</code></li>
</ul>
<p><code>protected</code> and <code>static protected</code> are propagated to the block of subclasses.</p>
<h2 id="shockdoc-comment"><a class="header" href="#shockdoc-comment">ShockDoc comment</a></h2>
<p>A class may be prefixed by a ShockDoc comment.</p>
<pre><code>/** Comment */
class C1 {}
</code></pre>
<h2 id="meta-data"><a class="header" href="#meta-data">Meta-data</a></h2>
<p>A class may have zero or more meta-data.</p>
<pre><code>[M1]
[M2]
class C1 {}
</code></pre>
<h2 id="inheritance"><a class="header" href="#inheritance">Inheritance</a></h2>
<pre><code>class A {}
class B extends A {}
</code></pre>
<h3 id="member-shadowing"><a class="header" href="#member-shadowing">Member shadowing</a></h3>
<p>Members from base classes <strong>must not</strong> be shadowed except for overriding methods.</p>
<pre><code>class C1 {
    function m() {}
}
class C2 extends C1 {
    function m() {} // ERROR!
}
</code></pre>
<h3 id="default-inheritance"><a class="header" href="#default-inheritance">Default inheritance</a></h3>
<p>By default a class, excluding <code>Object</code>, inherits <code>Object</code>. A class can extend at most one class.</p>
<h3 id="final-classes"><a class="header" href="#final-classes">Final classes</a></h3>
<p>A final class may not be extended:</p>
<pre><code>final class A {}

class B extends A {} // ERROR!
</code></pre>
<h3 id="implementing-interfaces"><a class="header" href="#implementing-interfaces">Implementing interfaces</a></h3>
<p>A class may implement zero or more interfaces:</p>
<pre><code>class C1 implements I1, I2 {
    //
}
</code></pre>
<h3 id="constructor-inheritance"><a class="header" href="#constructor-inheritance">Constructor inheritance</a></h3>
<p>If the constructor of a class is not explicitly defined, then it is based on the base class's constructor, using the same signature and initializing the instance with default field values:</p>
<pre><code>class A {
    var x:Number;
    function A(x:Number) {
        this.x = x;
    }
}
class B extends A {
    var y:Number = 10;
}
new B(0);
new B(); // ERROR!
</code></pre>
<h2 id="constructor"><a class="header" href="#constructor">Constructor</a></h2>
<p>The constructor of a class is a special initialization method named as the class itself, as in:</p>
<pre><code>class C1 {
    function C1() {}
}
</code></pre>
<h3 id="super-statement"><a class="header" href="#super-statement">Super statement</a></h3>
<p>The super statement is used to invoke the constructor from the base class from a subclass constructor.</p>
<p>A constructor must contain the super statement if a class is inherited which consists of a required constructor.</p>
<pre><code>class A {
    function A(x:Number) {}
}
class B extends A {
    function B() {
        super(0);
    }
}
</code></pre>
<h2 id="abstract-classes"><a class="header" href="#abstract-classes">Abstract classes</a></h2>
<p>An abstract class may not be directly instantiated through the <code>new</code> operator, and may define abstract methods. Non abstract subclasses are allowed to be instantiated.</p>
<pre><code>abstract class A {
    abstract function m():void;
}
</code></pre>
<h2 id="static-classes"><a class="header" href="#static-classes">Static classes</a></h2>
<p>A static class may not be instantiated or inherited, and by convention consists of static properties and methods.</p>
<pre><code>static class MyNamespace {
    public static const VALUE:Number = 10.5;
}
</code></pre>
<h2 id="events-2"><a class="header" href="#events-2">Events</a></h2>
<p>The class, in convention when either extending <code>EventTarget</code> or implementing <code>IEventTarget</code>, may define possibly emitted events through using multiple <code>Event</code> meta-data.</p>
<pre><code>/**
 * Event.
 */
[Event(name="eventName", type="T")]
/**
 * Target.
 */
class A extends EventTarget {}
</code></pre>
<h2 id="static-properties"><a class="header" href="#static-properties">Static properties</a></h2>
<p>Definitions marked <code>static</code> that appear within the <code>class</code> block are part of the static properties of the class, which are accessed as <code>C.n</code> where <code>C</code> is teh class and <code>n</code> the property name.</p>
<h2 id="instance-properties"><a class="header" href="#instance-properties">Instance properties</a></h2>
<p>Definitions not marked <code>static</code> that appear within the <code>class</code> block are part of the prototype of the class, and are called <em>instance</em> properties.</p>
<div style="break-before: page; page-break-before: always;"></div><h1 id="enumerations"><a class="header" href="#enumerations">Enumerations</a></h1>
<p>Enumerations are special classes consisting of zero or more variants.</p>
<pre><code>enum Variant {
    const VARIANT_ONE;
    const VARIANT_TWO = "variantTwo";
    const VARIANT_THREE = [2, "variantThree"];
}
</code></pre>
<blockquote>
<p><strong>Note</strong>: Variable definitions within an <code>enum</code> define static constants which are referred to as <em>variants</em>.</p>
</blockquote>
<h2 id="final"><a class="header" href="#final">Final</a></h2>
<p>Enumerations are final, so they cannot be extended.</p>
<h2 id="static"><a class="header" href="#static">Static</a></h2>
<p>Enumerations are static, so they cannot be instantiated through the <code>new</code> operator.</p>
<h2 id="type-inference"><a class="header" href="#type-inference">Type inference</a></h2>
<p>When the inference type in a string literal is an enumeration, the literal may identify a variant by its name.</p>
<pre><code>var val:Variant = "variantOne";
</code></pre>
<p>When the inference type in an array literal or object initializer is a flag enumeration, the literal may be used to identify multiple variants.</p>
<pre><code>[Flags]
enum F { const A, B, C }

const m:F = ["a", "b", "c"];
    // or
const m:F = { a: true, b: true, c: true };
</code></pre>
<h2 id="flag-enumerations"><a class="header" href="#flag-enumerations">Flag enumerations</a></h2>
<p>Flag enumerations differ from regular enumerations by having instances being able to contain zero or more variants.</p>
<pre><code>[Flags]
enum F { const A, B, C }
</code></pre>
<p>Flag enumerations may be assigned <code>undefined</code>, <code>null</code> or <code>[]</code> to indicate absence of variants.</p>
<h3 id="all-variants"><a class="header" href="#all-variants">All variants</a></h3>
<p>Obtain all variants of a flag enumeration by using the <code>**</code> expression with the enumeration as the inference type:</p>
<pre><code>var f:F = **;
</code></pre>
<h2 id="internation"><a class="header" href="#internation">Internation</a></h2>
<p>Flag enumeration objects are interned so that flags may be compared correctly.</p>
<pre><code>[Flags]
enum E { const A, B, C }

const obj:* = E(["a", "b"]);
trace(obj == E(["a", "b"]));
</code></pre>
<h2 id="customizing-the-numeric-type"><a class="header" href="#customizing-the-numeric-type">Customizing the numeric type</a></h2>
<p>Enumerations use the <code>Number</code> type by default to represent the variant values. The user is allowed to change the type to another numeric type through using a meta-data named after that numeric type.</p>
<pre><code>[decimal]
enum E1 {
    const A, B, C;
}
</code></pre>
<h2 id="variant-initializer"><a class="header" href="#variant-initializer">Variant initializer</a></h2>
<p>The initializer of a variant may be expressed in four different forms, or simply be omitted:</p>
<pre><code>StringLiteral
NumericLiteral
[StringLiteral, NumericLiteral]
[NumericLiteral, StringLiteral]
</code></pre>
<p>The <em>ArrayLiteral</em> syntax is used to allow specifying both a string and a number.</p>
<h2 id="variant-name"><a class="header" href="#variant-name">Variant name</a></h2>
<p>The variant name as declared by the <code>const</code> is determined as follows:</p>
<ol>
<li>Let r = empty string</li>
<li>If the initializer does not contain a string literal
<ol>
<li>Let orig = binding identifier name</li>
<li>r = a screaming snake case (<code>ABC_DEF</code>) to camel case (<code>abcDef</code>) conversion of orig.</li>
</ol>
</li>
<li>Else
<ol>
<li>r = the value of the string literal at the initializer.</li>
</ol>
</li>
<li>If r is already used by another variant's name
<ol>
<li>Throw a verify error</li>
</ol>
</li>
<li>Return r</li>
</ol>
<h2 id="variant-value"><a class="header" href="#variant-value">Variant value</a></h2>
<p>The variant value as declared by the <code>const</code> is determined as follows:</p>
<ol>
<li>If the enumeration is a flag enumeration
2. Return <em>DecideFlagValue</em>()</li>
<li>Return <em>DecideValue</em>()</li>
</ol>
<p><em>DecideValue</em>()</p>
<ol>
<li>Let r = zero</li>
<li>If the initializer does not contain a numeric literal
<ol>
<li>If there is no previous variant, return 0.</li>
<li>Let k = previous variant's value</li>
<li>r = k + 1</li>
</ol>
</li>
<li>Else
<ol>
<li>r = the value of the numeric literal at the initializer.</li>
</ol>
</li>
<li>If r is already used by another variant's value
<ol>
<li>Throw a verify error</li>
</ol>
</li>
<li>Return r</li>
</ol>
<p><em>DecideFlagValue</em>()</p>
<ol>
<li>Let r = zero</li>
<li>If the initializer does not contain a numeric literal
<ol>
<li>If there is no previous variant, return 1.</li>
<li>Let k = previous variant's value</li>
<li>r = k * 2</li>
</ol>
</li>
<li>Else
<ol>
<li>r = the value of the numeric literal at the initializer.</li>
<li>If r is not one or a power of two
<ol>
<li>Throw a verify error</li>
</ol>
</li>
</ol>
</li>
<li>If r is already used by another variant's value
<ol>
<li>Throw a verify error</li>
</ol>
</li>
<li>Return r</li>
</ol>
<h2 id="implicitly-added-methods"><a class="header" href="#implicitly-added-methods">Implicitly added methods</a></h2>
<h3 id="for-all-enumerations"><a class="header" href="#for-all-enumerations">For all enumerations</a></h3>
<h4 id="valueof"><a class="header" href="#valueof">valueOf()</a></h4>
<pre><code>public override function valueOf():T {
    //
}
</code></pre>
<p>Returns the numeric value of the enumeration instance, where <code>T</code> is the numeric type.</p>
<h4 id="tostring"><a class="header" href="#tostring">toString()</a></h4>
<pre><code>public override function toString():String {
    //
}
</code></pre>
<p>Returns the name of the enumeration instance. For a flag enumeration, returns the names of the enumeration instance delimited by comma (<strong>,</strong>) by ascending value order.</p>
<h3 id="for-flag-enumerations"><a class="header" href="#for-flag-enumerations">For flag enumerations</a></h3>
<h4 id="shock_proxyhas"><a class="header" href="#shock_proxyhas">shock_proxy::has()</a></h4>
<pre><code>shock_proxy function has(v:E):Boolean {
    //
}
</code></pre>
<p>Returns a boolean indicating whether the instance contains the specified flags or not, where <code>E</code> is the enumeration itself.</p>
<p>This allows for <code>f in e</code> expressions.</p>
<h4 id="with"><a class="header" href="#with">with()</a></h4>
<pre><code>public function with(v:E):E {
    //
}
</code></pre>
<p>Returns a new value containing the specified flags, where <code>E</code> is the enumeration itself.</p>
<h4 id="without"><a class="header" href="#without">without()</a></h4>
<pre><code>public function without(v:E):E {
    //
}
</code></pre>
<p>Returns a new value removing the specified flags, where <code>E</code> is the enumeration itself.</p>
<h4 id="toggled"><a class="header" href="#toggled">toggled()</a></h4>
<pre><code>public function toggled(v:E):E {
    //
}
</code></pre>
<p>Returns a new value toggling the specified flags, where <code>E</code> is the enumeration itself.</p>
<h2 id="customized-methods"><a class="header" href="#customized-methods">Customized methods</a></h2>
<p>Enumerations support customized methods:</p>
<pre><code>enum E {
    const A, B, C;
    function get isA() this == "a";
}
</code></pre>
<p>Enumerations are prohibited from using variable definitions for purposes other than defining variants.</p>
<div style="break-before: page; page-break-before: always;"></div><h1 id="interfaces"><a class="header" href="#interfaces">Interfaces</a></h1>
<p>Interfaces are user defined, non opaque types that may be implemented by classes through their <code>implements</code> clause.</p>
<pre><code>interface I {
    //
    function m() : void;

    //
    function get x() : Number;
    function set x(value);
}

interface Ia extends I {}
</code></pre>
<p>The <code>interface</code> block may only contain function definitions, including regular methods, getters and setters.</p>
<h2 id="basemost-type"><a class="header" href="#basemost-type">Basemost type</a></h2>
<p>An <code>interface</code> is a subtype of <code>Object</code>, although compile-time property lookups do not inherit <code>Object</code> properties.</p>
<h2 id="shockdoc-comment-1"><a class="header" href="#shockdoc-comment-1">ShockDoc comment</a></h2>
<p>An interface may be prefixed by a ShockDoc comment.</p>
<pre><code>/** Comment */
interface I {}
</code></pre>
<h2 id="meta-data-1"><a class="header" href="#meta-data-1">Meta-data</a></h2>
<p>An interface may have zero or more meta-data.</p>
<pre><code>[M1]
[M2]
interface I {}
</code></pre>
<h2 id="inheritance-1"><a class="header" href="#inheritance-1">Inheritance</a></h2>
<p>An interface may extend other interfaces through the <code>extends</code> clause.</p>
<pre><code>interface I3 extends I1, I2 {}
</code></pre>
<h3 id="shadowing-members"><a class="header" href="#shadowing-members">Shadowing members</a></h3>
<p>Members from base interfaces <strong>must not</strong> be shadowed.</p>
<pre><code>interface I1 {
    function m() {}
}
interface I2 extends I1 {
    function m() {} // ERROR!
}
</code></pre>
<h2 id="required-methods"><a class="header" href="#required-methods">Required methods</a></h2>
<p>When interface methods omit their body, they are classified as <em>required</em> methods.</p>
<pre><code>interface I {
    function m():void;
}
</code></pre>
<h2 id="provided-methods"><a class="header" href="#provided-methods">Provided methods</a></h2>
<p>When interface methods contain a body, they are classified as <em>provided</em> methods.</p>
<pre><code>interface I {
    function m() {
        //
    }
}
</code></pre>
<h2 id="method-annotations"><a class="header" href="#method-annotations">Method annotations</a></h2>
<p>As annotations, interface methods may have nothing but an access modifier that is allowed to be anything but a direct reserved namespace.</p>
<pre><code>interface I {
    shock_proxy function get(key:String):String;
}
</code></pre>
<h2 id="events-3"><a class="header" href="#events-3">Events</a></h2>
<p>The interface, in convention when implementing <code>IEventTarget</code>, may define possibly emitted events through using multiple <code>Event</code> meta-data.</p>
<pre><code>/**
 * Event.
 */
[Event(name="eventName", type="T")]
/**
 * Target.
 */
interface I extends IEventTarget {}
</code></pre>
<div style="break-before: page; page-break-before: always;"></div><h1 id="variables"><a class="header" href="#variables">Variables</a></h1>
<p>A variable may be read-only or writeable, and consists of a type.</p>
<pre><code>var x = 0
const y = 10
</code></pre>
<h2 id="shockdoc-comment-2"><a class="header" href="#shockdoc-comment-2">ShockDoc comment</a></h2>
<p>A ShockDoc comment can be applied to a variable.</p>
<pre><code>/** Comment */
var x
</code></pre>
<h2 id="meta-data-2"><a class="header" href="#meta-data-2">Meta-data</a></h2>
<p>A variable may have zero or more meta-data.</p>
<pre><code>[M1]
[M2]
var x
</code></pre>
<h2 id="initializer"><a class="header" href="#initializer">Initializer</a></h2>
<p>If the initializer of a variable is a constant, then the variable consists of a constant initializer.</p>
<pre><code>var x = 0
</code></pre>
<h2 id="local-shadowing"><a class="header" href="#local-shadowing">Local shadowing</a></h2>
<p>Re-declaring a variable is allowed inside activation blocks.</p>
<pre><code>var m:* = central.manager;
// more code...
var m = Manager(m);
</code></pre>
<div style="break-before: page; page-break-before: always;"></div><h1 id="virtual-variables"><a class="header" href="#virtual-variables">Virtual variables</a></h1>
<p>Virtual variables consist of either:</p>
<ul>
<li>a getter and a setter (writable);</li>
<li>a getter (read-only);</li>
<li>a setter (write-only).</li>
</ul>
<p>A virtual variable's type is determined based on the getter or setter.</p>
<pre><code>function get x():float 10;
function set x(val) {
    //
}
</code></pre>
<h2 id="shockdoc-comment-3"><a class="header" href="#shockdoc-comment-3">ShockDoc comment</a></h2>
<p>A virtual variable derives ShockDoc comments from its getter or setter.</p>
<pre><code>/** Comment */
function get x():float 10;
</code></pre>
<h2 id="meta-data-3"><a class="header" href="#meta-data-3">Meta-data</a></h2>
<p>A virtual variable collects meta-data from its getter or setter.</p>
<pre><code>[M1]
[M2]
function get x():float 10;
</code></pre>
<div style="break-before: page; page-break-before: always;"></div><h1 id="methods"><a class="header" href="#methods">Methods</a></h1>
<p>A method is a function that may be invoked. An instance method is a method defined in a <code>class</code>, <code>enum</code> or <code>interface</code> block which is not marked <code>static</code>.</p>
<pre><code>function m() {}
</code></pre>
<p>Getters and setters are methods belonging to a virtual variable:</p>
<pre><code>function get x():decimal 10;
function set x(val) {}
</code></pre>
<p>Constructors are methods that implement initialization for a class instance, as in:</p>
<pre><code>class A {
    function A() {}
}
</code></pre>
<h2 id="shockdoc-comment-4"><a class="header" href="#shockdoc-comment-4">ShockDoc comment</a></h2>
<p>A ShockDoc comment can be applied to a method.</p>
<pre><code>/** Comment */
function m() {}
</code></pre>
<h2 id="meta-data-4"><a class="header" href="#meta-data-4">Meta-data</a></h2>
<p>A method may have zero or more meta-data.</p>
<pre><code>[M1]
[M2]
function m() {}
</code></pre>
<h2 id="final-method"><a class="header" href="#final-method">Final method</a></h2>
<p>Instance methods may have a <code>final</code> modifier, indicating that they are not to overriden by subclasses.</p>
<pre><code>class A {
    final function m() {}
}
</code></pre>
<h2 id="abstract-method"><a class="header" href="#abstract-method">Abstract method</a></h2>
<p>Instance methods may have an <code>abstract</code> modifier under an <code>abstract</code> class, indicating that they must be overriden by subclasses.</p>
<pre><code>abstract class A {
    abstract function m():void;
}
</code></pre>
<h2 id="generators"><a class="header" href="#generators">Generators</a></h2>
<p>A method is a generator if the <code>yield</code> operator appears at least once in the method's body. A generator is a method that evaluates like an iterator, consumed in pauses of <code>yield</code> operators until it hits a <code>return</code> statement or the end of code. A generator returns a <code>Generator.&lt;T&gt;</code> object.</p>
<pre><code>function g():Number {
    yield 100.5;
}
</code></pre>
<p>If a method uses both <code>yield</code> and <code>await</code>, it is considered an iterator of <code>Promise</code>, therefore returning <code>Generator.&lt;Promise.&lt;T&gt;&gt;</code>.</p>
<h2 id="asynchronous-methods"><a class="header" href="#asynchronous-methods">Asynchronous methods</a></h2>
<p>A method is asynchronous if the <code>await</code> operator appears at least once in the method's body. An asynchronous method returns a <code>Promise.&lt;T&gt;</code> object.</p>
<pre><code>function f():void {
    await otherF();
}
</code></pre>
<p>If a method uses both <code>yield</code> and <code>await</code>, it is considered an iterator of <code>Promise</code>, therefore returning <code>Generator.&lt;Promise.&lt;T&gt;&gt;</code>.</p>
<h2 id="multi-methods"><a class="header" href="#multi-methods">Multi-methods</a></h2>
<p>A method may be defined more than once with varying signatures, turning into a <em>multi-method</em>. Signatures must differ by the parameter list and not just the result type.</p>
<pre><code>function f():decimal {
    //
}
function f(val:decimal):Chainable {
    //
}
</code></pre>
<h2 id="overriding"><a class="header" href="#overriding">Overriding</a></h2>
<p>An instance method may override a method in a base class through using the <code>override</code> modifier:</p>
<pre><code>override protected function m() {
    //
}
</code></pre>
<p><strong>Remarks</strong></p>
<ul>
<li>A getter must override a getter, and a setter must override a setter.</li>
<li>For a multi method, the override shall match a specific signature.</li>
</ul>
<h3 id="overriding-rules"><a class="header" href="#overriding-rules">Overriding rules</a></h3>
<p>A method S may override a method B with the following rules:</p>
<ul>
<li>S must begin with the same list of parameters as that of B.</li>
<li>If B does not contain a rest parameter
<ul>
<li>S may include additional <em>optional</em> parameters and/or a <em>rest</em> parameter.</li>
</ul>
</li>
<li>S must have the same result type of B, or a subtype of the B result type.</li>
</ul>
<h2 id="bound-methods"><a class="header" href="#bound-methods">Bound methods</a></h2>
<p>Instance methods are <em>bound</em> such that retrieving a method from an instance will return a method tied to the instance.</p>
<pre><code>class A {
    function m():this {
        return this;
    }
}
const o = new A;
const { m } = o
trace(m == o.m); // true
trace(o == m());
</code></pre>
<div style="break-before: page; page-break-before: always;"></div><h1 id="aliases"><a class="header" href="#aliases">Aliases</a></h1>
<p>Aliases are used in different places of the language:</p>
<pre><code>import CT = com.business.coreRT.enum.ContactType;
import q = com.business.quantum.*;
type U = (decimal, String);
namespace special_version;
</code></pre>
<h2 id="shockdoc-comment-5"><a class="header" href="#shockdoc-comment-5">ShockDoc comment</a></h2>
<p>An alias may be prefixed by a ShockDoc comment.</p>
<pre><code>/** Comment */
type Params = {
    x : decimal,
};
</code></pre>
<div style="break-before: page; page-break-before: always;"></div><h1 id="meta-data-5"><a class="header" href="#meta-data-5">Meta-data</a></h1>
<p>Meta-data are bracketed, arbitrary entries of textual key-value pairs that may be attached to ShockScript definitions. Meta-data are not unique and may appear more than once, as well as their key-value pairs.</p>
<pre><code>[M1]
class A {}

[M1(x="y", z="w")]
class A {}

[M1(y)]
class A {}
</code></pre>
<p>Keyless entries are a single identifier (equivalent to a string) or a string literal not accompanied by a key.</p>
<h2 id="reserved-meta-data"><a class="header" href="#reserved-meta-data">Reserved meta-data</a></h2>
<p>Certain meta-data are reserved in certain contexts, such as <code>Event</code> and <code>Limit</code>.</p>
<div style="break-before: page; page-break-before: always;"></div><h1 id="generics"><a class="header" href="#generics">Generics</a></h1>
<p>Classes, interfaces, type aliases and functions may specify type parameters, turning into <em>generic</em> entities. ShockScript implements generic entities using polymorphism.</p>
<blockquote>
<p><strong>Note</strong>: Array data types of <code>Number</code>, <code>float</code>, <code>decimal</code>, <code>int</code> and <code>uint</code> are specialized so they are represented in a memory efficient way.</p>
</blockquote>
<pre><code>class A.&lt;T&gt; {
    // code
}
interface I.&lt;T&gt; {
    // code
}

type Alias.&lt;T&gt; = (decimal, [T]);

function f.&lt;T&gt;():void {
}
</code></pre>
<h2 id="parameter-constraints"><a class="header" href="#parameter-constraints">Parameter constraints</a></h2>
<p>Type parameters may be attached multiple constraints.</p>
<pre><code>[Limit(T, subtypeOf="A")]
/**
 * Some function.
 */
function f.&lt;T&gt;(o:T) {
    //
}

[Limit(E, eventOf="A", match="type")]
/**
 * Another function.
 */
function f.&lt;E&gt;(type:E.name, value:E.type) {
    //
}

[Limit(E, eventOf="A", match="object")]
/**
 * Yet another function.
 */
function f.&lt;E&gt;(value:E) {
    //
}
</code></pre>
<h3 id="eventof-constraints"><a class="header" href="#eventof-constraints">“eventOf” constraints</a></h3>
<p><code>eventOf</code> constraints allow inspecting available events as defined by the <code>Event</code> meta-data in classes and interfaces, including the inherited events and events from the implemented interfaces.</p>
<p><code>eventOf</code> constraints are allowed to take <code>this</code> as the base type, reflecting the current class's events:</p>
<pre><code>package com.business.coreRT.events {
    /**
     * Event dispatcher.
     */
    public class EventTarget {

        [Limit(E, eventOf="this", match="object")]
        /**
         * Dispatches an event.
         */
        public function emit.&lt;E&gt;(e:E):Boolean {
            //
        }
    }
}
</code></pre>
<ul>
<li><code>match="type"</code> yields the name-type pair of an event. The <code>.type</code> property of the pair relies on previous introduction of the respective <code>.name</code> somewhere.</li>
<li><code>match="object"</code> ensures event creation is correct by analyzing the <code>new E(type, ...)</code> expression.</li>
</ul>
<blockquote>
<p><strong>Note</strong>: The <code>match="type"</code> constraint contributes a <code>name</code> field that yields the <code>String</code> type, but its purpose is for auto completion in integrated development environments.</p>
</blockquote>
<div style="break-before: page; page-break-before: always;"></div><h1 id="lexical-scopes"><a class="header" href="#lexical-scopes">Lexical scopes</a></h1>
<h2 id="internal-properties"><a class="header" href="#internal-properties">Internal properties</a></h2>
<div class="table-wrapper"><table><thead><tr><th>Name</th><th>Description</th></tr></thead><tbody>
<tr><td>[[<em>Parent</em>]]</td><td>Optional parent scope.</td></tr>
<tr><td>[[<em>OpenNamespaces</em>]]</td><td>Open namespace list.</td></tr>
<tr><td>[[<em>Properties</em>]]</td><td>The scope properties.</td></tr>
<tr><td>[[<em>Imports</em>]]</td><td>The import list.</td></tr>
</tbody></table>
</div>
<h3 id="import-list"><a class="header" href="#import-list">Import list</a></h3>
<p>The import list may contain package single imports and package wildcard imports.</p>
<h2 id="scope-variants"><a class="header" href="#scope-variants">Scope variants</a></h2>
<h3 id="with-scope"><a class="header" href="#with-scope">With scope</a></h3>
<p>The <code>with</code> scope is created by the <code>with</code> statement, causing the wildcard <code>*</code> expression to resolve to the parenthesized object.</p>
<pre><code>with (object.from.somewhere)
    *.x *= 10,
    *.y *= 3;
</code></pre>
<h4 id="added-internal-properties"><a class="header" href="#added-internal-properties">Added internal properties</a></h4>
<div class="table-wrapper"><table><thead><tr><th>Name</th><th>Description</th></tr></thead><tbody>
<tr><td>[[<em>Object</em>]]</td><td>Object used in the <code>with</code> statement.</td></tr>
</tbody></table>
</div>
<h3 id="class-scope"><a class="header" href="#class-scope">Class scope</a></h3>
<h4 id="added-internal-properties-1"><a class="header" href="#added-internal-properties-1">Added internal properties</a></h4>
<div class="table-wrapper"><table><thead><tr><th>Name</th><th>Description</th></tr></thead><tbody>
<tr><td>[[<em>Class</em>]]</td><td>Class object.</td></tr>
</tbody></table>
</div>
<h3 id="enum-scope"><a class="header" href="#enum-scope">Enum scope</a></h3>
<h4 id="added-internal-properties-2"><a class="header" href="#added-internal-properties-2">Added internal properties</a></h4>
<div class="table-wrapper"><table><thead><tr><th>Name</th><th>Description</th></tr></thead><tbody>
<tr><td>[[<em>Class</em>]]</td><td>Class object.</td></tr>
</tbody></table>
</div>
<h3 id="interface-scope"><a class="header" href="#interface-scope">Interface scope</a></h3>
<h4 id="added-internal-properties-3"><a class="header" href="#added-internal-properties-3">Added internal properties</a></h4>
<div class="table-wrapper"><table><thead><tr><th>Name</th><th>Description</th></tr></thead><tbody>
<tr><td>[[<em>Interface</em>]]</td><td>The interface.</td></tr>
</tbody></table>
</div>
<h3 id="package-scope"><a class="header" href="#package-scope">Package scope</a></h3>
<h4 id="added-internal-properties-4"><a class="header" href="#added-internal-properties-4">Added internal properties</a></h4>
<div class="table-wrapper"><table><thead><tr><th>Name</th><th>Description</th></tr></thead><tbody>
<tr><td>[[<em>Package</em>]]</td><td>Package.</td></tr>
</tbody></table>
</div>
<h3 id="activation"><a class="header" href="#activation">Activation</a></h3>
<p>Method bodies create an activation as scope.</p>
<h4 id="added-internal-properties-5"><a class="header" href="#added-internal-properties-5">Added internal properties</a></h4>
<div class="table-wrapper"><table><thead><tr><th>Name</th><th>Description</th></tr></thead><tbody>
<tr><td>[[<em>This</em>]]</td><td>The <code>this</code> object.</td></tr>
<tr><td>[[<em>Method</em>]]</td><td>Method.</td></tr>
</tbody></table>
</div><div style="break-before: page; page-break-before: always;"></div><h1 id="default-lexical-scope"><a class="header" href="#default-lexical-scope">Default lexical scope</a></h1>
<p>The topmost scope from which all scopes inherit is implicitly created by ShockScript.</p>
<h2 id="imports"><a class="header" href="#imports">Imports</a></h2>
<p>The topmost scope imports the top-level package by wildcard. It is allowed to shadow names from the top-level package, in which case, the <code>global</code> alias may be used to access the top-level package.</p>
<h2 id="global"><a class="header" href="#global">global</a></h2>
<p>The topmost scope defines a <code>global</code> property, which is an alias to a package wildcard import of the top-level package.</p>
<h2 id="intl"><a class="header" href="#intl">Intl</a></h2>
<p>The topmost scope defines an <code>Intl</code> property, which is an alias to a package wildcard import of the <code>shockscript.intl</code> package.</p>
<h2 id="temporal"><a class="header" href="#temporal">Temporal</a></h2>
<p>The topmost scope defines an <code>Temporal</code> property, which is an alias to a package wildcard import of the <code>shockscript.temporal</code> package.</p>
<h2 id="globalreflection"><a class="header" href="#globalreflection">GlobalReflection</a></h2>
<p>The topmost scope defines an <code>GlobalReflection</code> property, which is an alias to a package wildcard import of the <code>shockscript.reflection.global</code> package.</p>
<div style="break-before: page; page-break-before: always;"></div><h1 id="conditional-compilation-1"><a class="header" href="#conditional-compilation-1">Conditional compilation</a></h1>
<p>The <code>NAMESPACE::CONSTANT</code> expression may match a configuration constant used for conditional compilation.</p>
<pre><code>NAMESPACE::CONSTANT {
    //
}

NAMESPACE::CONSTANT var x
</code></pre>
<p>The following program uses an inline constant.</p>
<pre><code>trace(NAMESPACE::CONSTANT)
</code></pre>
<div style="break-before: page; page-break-before: always;"></div><h1 id="integrated-configuration-constants"><a class="header" href="#integrated-configuration-constants">Integrated configuration constants</a></h1>
<h2 id="configdebug"><a class="header" href="#configdebug">CONFIG::DEBUG</a></h2>
<p>The <code>CONFIG::DEBUG</code> constant indicates whether or not the program is targetting a debug build.</p>
<h2 id="configrelease"><a class="header" href="#configrelease">CONFIG::RELEASE</a></h2>
<p>The <code>CONFIG::RELEASE</code> constant indicates whether or not the program is targetting a release build.</p>
<h2 id="configtest"><a class="header" href="#configtest">CONFIG::TEST</a></h2>
<p>The <code>CONFIG::TEST</code> constant indicates whether or not the program is compiling for evaluating unit tests.</p>
<div style="break-before: page; page-break-before: always;"></div><h1 id="unit-testing"><a class="header" href="#unit-testing">Unit testing</a></h1>
<p>Basic unit testing may be done by defining functions with the <code>Test</code> meta-data at a package-level.</p>
<pre><code>package com.example.foo.tests {
    // Unit tests
    CONFIG::TEST {
        [Test]
        /**
         * Test foo.
         */
        public function testFoo():void {
            assertEquals(2 + 2, 4);
        }
    }
}
</code></pre>
<div style="break-before: page; page-break-before: always;"></div><h1 id="shockdoc-comments-1"><a class="header" href="#shockdoc-comments-1">ShockDoc comments</a></h1>
<p>ShockDoc are documentation comments that use the format <code>/** */</code>. Markdown notation is supported in ShockDoc comments.</p>
<p>For each line, the beginning whitespace is stripped, then the <code>*</code> character and a single following white space character are stripped, and the resting characters are the actual line contents.</p>
<p>Line contents may start with a tag (such as <code>@deprecated</code>). Tags may span multiple lines until the next tag appears; tags that do not accept content do not span any more characters.</p>
<p>Code blocks (whose delimiters consist of at least three backticks <strong>```</strong>) as expressed in Markdown cause tags to be ignored in the code content, as in:</p>
<pre><code>/**
 * ```plain
 * @deprecated
 * ```
 */
</code></pre>
<h2 id="local-images"><a class="header" href="#local-images">Local images</a></h2>
<p>ShockDoc comments may refer to relative images through the Markdown notation <code>![image](./path/to/image)</code>.</p>
<h2 id="supported-tags"><a class="header" href="#supported-tags">Supported tags</a></h2>
<h3 id="copy"><a class="header" href="#copy">@copy</a></h3>
<p>Copies ShockDoc comment from another definition. Use a <code>#x</code> component to refer to an instance property.</p>
<pre><code class="language-plain">@copy A
@copy A.w
@copy A#x
@copy #x
</code></pre>
<h3 id="default"><a class="header" href="#default">@default</a></h3>
<p>Default value as an uninterpreted expression.</p>
<pre><code>@default exp
</code></pre>
<h3 id="deprecated"><a class="header" href="#deprecated">@deprecated</a></h3>
<pre><code class="language-plain">@deprecated [Description]
</code></pre>
<h3 id="example"><a class="header" href="#example">@example</a></h3>
<pre><code>@example
The following...
</code></pre>
<h3 id="eventparam"><a class="header" href="#eventparam">@eventparam</a></h3>
<p>Indicates that a record type's property is an event handler. The tag does nothing but move the item to the <em>Events</em> section of the documentation, similiar to how happens with the <code>Event</code> meta-data used in class definitions.</p>
<pre><code class="language-plain">@eventparam
</code></pre>
<h3 id="inheritdoc"><a class="header" href="#inheritdoc">@inheritDoc</a></h3>
<p>Inherits documentation from base class or base class's item.</p>
<pre><code class="language-plain">@inheritDoc
</code></pre>
<h3 id="internal"><a class="header" href="#internal">@internal</a></h3>
<p>Internal comment for an item (not included in the generated documentation).</p>
<pre><code class="language-plain">@internal Comment.
</code></pre>
<h3 id="param"><a class="header" href="#param">@param</a></h3>
<pre><code class="language-plain">@param paramName Description
</code></pre>
<h3 id="private"><a class="header" href="#private">@private</a></h3>
<p>Hides an item from the generated documentation.</p>
<pre><code class="language-plain">@private
</code></pre>
<h3 id="return"><a class="header" href="#return">@return</a></h3>
<pre><code class="language-plain">@return Description
</code></pre>
<h3 id="see"><a class="header" href="#see">@see</a></h3>
<p>Where <code>item</code> maybe an item reference with optional <code>#x</code> instance property, or just an instance property <code>#x</code>.</p>
<pre><code class="language-plain">@see item [Display text]
</code></pre>
<h3 id="throws"><a class="header" href="#throws">@throws</a></h3>
<pre><code class="language-plain">@throws ClassName [Description]
</code></pre>
<div style="break-before: page; page-break-before: always;"></div><h1 id="proxies"><a class="header" href="#proxies">Proxies</a></h1>
<p>Methods of the <code>shock_proxy</code> namespace may be implemented in a class or interface for overriding language behavior, known as <em>proxies</em>.</p>
<h2 id="shock_proxycall"><a class="header" href="#shock_proxycall">shock_proxy::call()</a></h2>
<p>A static <code>shock_proxy::call()</code> method may be defined with any number of parameters and any result type, overriding the behavior of calling the class object.</p>
<pre><code>shock_proxy static function call():T {}
</code></pre>
<p>A multi-method may be used, allowing for multiple call signatures.</p>
<h2 id="shock_proxyget"><a class="header" href="#shock_proxyget">shock_proxy::get()</a></h2>
<blockquote>
<p><strong>Note</strong>: Overriding the property accessor with a possibly <code>String</code> or <code>QName</code> key type (including base types <code>*</code> and <code>Object</code>) will override all names (like <code>.x</code>), except when calling a method (like <code>.m()</code>). In that case, a class is said to be <em>dynamic</em>.</p>
<p>If the user needs to access an instance variable in such a case it is recommended to use a fixed expression as in</p>
<pre><code>&lt;?fixed={object.q::n}?&gt;
</code></pre>
</blockquote>
<pre><code>shock_proxy function get(key:K):V {
    //
}
</code></pre>
<h2 id="shock_proxyset"><a class="header" href="#shock_proxyset">shock_proxy::set()</a></h2>
<blockquote>
<p><strong>Note</strong>: Overriding the property accessor with a possibly <code>String</code> or <code>QName</code> key type (including base types <code>*</code> and <code>Object</code>) will override all names (like <code>.x</code>), except when calling a method (like <code>.m()</code>). In that case, a class is said to be <em>dynamic</em>.</p>
</blockquote>
<pre><code>shock_proxy function set(key:K, value:V):void {
    //
}
</code></pre>
<h2 id="shock_proxydelete"><a class="header" href="#shock_proxydelete">shock_proxy::delete()</a></h2>
<blockquote>
<p><strong>Note</strong>: Overriding the property accessor with a possibly <code>String</code> or <code>QName</code> key type (including base types <code>*</code> and <code>Object</code>) will override all names (like <code>.x</code>), except when calling a method (like <code>.m()</code>). In that case, a class is said to be <em>dynamic</em>.</p>
</blockquote>
<pre><code>shock_proxy function delete(key:K):Boolean {
    //
}
</code></pre>
<h2 id="shock_proxyhas-1"><a class="header" href="#shock_proxyhas-1">shock_proxy::has()</a></h2>
<p>Overrides the behavior of the <code>in</code> operator.</p>
<pre><code>shock_proxy function has(key:K):Boolean {
    //
}
</code></pre>
<h2 id="shock_proxygetattribute"><a class="header" href="#shock_proxygetattribute">shock_proxy::getAttribute()</a></h2>
<p>Overrides the behavior of the <code>.@k</code> accessor.</p>
<pre><code>shock_proxy function getAttribute(key:K):V {
    //
}
</code></pre>
<h2 id="shock_proxysetattribute"><a class="header" href="#shock_proxysetattribute">shock_proxy::setAttribute()</a></h2>
<p>Overrides the behavior of the <code>.@k = v</code> accessor.</p>
<pre><code>shock_proxy function setAttribute(key:K, value:V):void {
    //
}
</code></pre>
<h2 id="shock_proxydeleteattribute"><a class="header" href="#shock_proxydeleteattribute">shock_proxy::deleteAttribute()</a></h2>
<p>Overrides the behavior of the <code>delete (...).@k</code> accessor.</p>
<pre><code>shock_proxy function deleteAttribute(key:K):Boolean {
    //
}
</code></pre>
<h2 id="shock_proxyfilter"><a class="header" href="#shock_proxyfilter">shock_proxy::filter()</a></h2>
<p>Overrides the behavior of the filter operator (<code>.(test)</code>).</p>
<pre><code>shock_proxy function filter(testFn:function(T):Boolean):E {
    //
}
</code></pre>
<h2 id="shock_proxydescendants"><a class="header" href="#shock_proxydescendants">shock_proxy::descendants()</a></h2>
<p>Overrides the behavior of the descendants operator (<code>..x</code>). The parameter is expected to be typed <code>String</code> or <code>QName</code>.</p>
<pre><code>shock_proxy function descendants(name:QName):E {
    //
}
</code></pre>
<div style="break-before: page; page-break-before: always;"></div><h1 id="lexical-conventions"><a class="header" href="#lexical-conventions">Lexical conventions</a></h1>
<p>This section defines the lexical grammar of the ShockScript language.</p>
<p>The tokenizer scans one of the following input goal symbols depending on the syntactic context: <em>InputElementDiv</em>, <em>InputElementRegExp</em>, <em>InputElementXMLTag</em>, <em>InputElementXMLPI</em>, <em>InputElementXMLContent</em>.</p>
<p>The following program illustrates how the tokenizer decides which is the input goal symbol to scan:</p>
<pre><code>/(?:)/       ;
a / b        ;
&lt;a&gt;Text&lt;/a&gt;  ;
</code></pre>
<p>The following table indicates which is the input goal symbol that is scanned for each of the tokens comprising the previous program:</p>
<div class="table-wrapper"><table><thead><tr><th>Token</th><th>Input goal</th></tr></thead><tbody>
<tr><td>/(?:)/</td><td><em>InputElementRegExp</em></td></tr>
<tr><td>;</td><td><em>InputElementDiv</em></td></tr>
<tr><td>a</td><td><em>InputElementRegExp</em></td></tr>
<tr><td>/</td><td><em>InputElementDiv</em></td></tr>
<tr><td>b</td><td><em>InputElementRegExp</em></td></tr>
<tr><td>;</td><td><em>InputElementDiv</em></td></tr>
<tr><td>&lt;</td><td><em>InputElementRegExp</em></td></tr>
<tr><td>a</td><td><em>InputElementXMLTag</em></td></tr>
<tr><td>&gt;</td><td><em>InputElementXMLTag</em></td></tr>
<tr><td>Text</td><td><em>InputElementXMLContent</em></td></tr>
<tr><td>&lt;/</td><td><em>InputElementXMLContent</em></td></tr>
<tr><td>a</td><td><em>InputElementXMLTag</em></td></tr>
<tr><td>&gt;</td><td><em>InputElementXMLTag</em></td></tr>
<tr><td>;</td><td><em>InputElementDiv</em></td></tr>
</tbody></table>
</div>
<p>The <em>InputElementXMLPI</em> goal symbol must be used when parsing the <code>&lt;?fixed={exp}?&gt;</code> markup.</p>
<p><strong>Syntax</strong></p>
<ul>
    <i>InputElementDiv</i> ::
    <ul>
        <i>WhiteSpace</i><br>
        <i>LineTerminator</i><br>
        <i>Comment</i><br>
        <i>Identifier</i><br>
        <i>ReservedWord</i><br>
        <i>Punctuator</i><br>
        <b>/</b><br>
        <b>/=</b><br>
        <i>NumericLiteral</i><br>
        <i>StringLiteral</i>
    </ul>
</ul>
<ul>
    <i>InputElementRegExp</i> ::
    <ul>
        <i>WhiteSpace</i><br>
        <i>LineTerminator</i><br>
        <i>Comment</i><br>
        <i>Identifier</i><br>
        <i>ReservedWord</i><br>
        <i>Punctuator</i><br>
        <i>NumericLiteral</i><br>
        <i>StringLiteral</i><br>
        <i>RegularExpressionLiteral</i><br>
        <i>XMLMarkup</i><br>
        <b>&lt;?fixed=&#x7B;</b><br>
    </ul>
</ul>
<ul>
    <i>InputElementXMLTag</i> ::
    <ul>
        <i>XMLName</i><br>
        <i>XMLTagPunctuator</i><br>
        <i>XMLAttributeValue</i><br>
        <i>XMLWhitespace</i><br>
        <b>&#x7B;</b>
    </ul>
</ul>
<ul>
    <i>InputElementXMLPI</i> ::
    <ul>
        <b>?&gt;</b>
    </ul>
</ul>
<ul>
    <i>InputElementXMLContent</i> ::
    <ul>
        <i>XMLMarkup</i><br>
        <i>XMLText</i><br>
        <b>&#x7B;</b><br>
        <b>&lt;</b> [lookahead ∉ { <b>?</b>, <b>!</b>, <b>/</b> }]<br>
        <b>&lt;/</b>
    </ul>
</ul>
<h2 id="source-characters"><a class="header" href="#source-characters">Source Characters</a></h2>
<p><strong>Syntax</strong></p>
<ul>
    <i>SourceCharacter</i> ::
    <ul>
        Unicode code point
    </ul>
</ul>
<ul>
    <i>SourceCharacters</i> ::
    <ul>
        <i>SourceCharacter</i> <i>SourceCharacters</i><sub>opt</sub>
    </ul>
</ul>
<h2 id="white-space"><a class="header" href="#white-space">White Space</a></h2>
<p>The <em>WhiteSpace</em> token is filtered out by the lexical scanner.</p>
<p><strong>Syntax</strong></p>
<ul>
    <i>WhiteSpace</i> ::
    <ul>
        U+09 tab<br>
        U+0B vertical tab<br>
        U+0C form feed<br>
        U+20 space<br>
        U+A0 no-break space<br>
        Unicode “space separator”
    </ul>
</ul>
<h2 id="line-terminator"><a class="header" href="#line-terminator">Line Terminator</a></h2>
<p>The <em>LineTerminator</em> token is filtered out by the lexical scanner, however it may result in a <em>VirtualSemicolon</em> to be inserted.</p>
<p><strong>Syntax</strong></p>
<ul>
    <i>LineTerminator</i> ::
    <ul>
        U+0A line feed<br>
        U+0D carriage return<br>
        U+2028 line separator<br>
        U+2029 paragraph separator
    </ul>
</ul>
<h2 id="comment"><a class="header" href="#comment">Comment</a></h2>
<p>The <em>Comment</em> token is filtered out by the lexical scanner, however it propagates any <em>LineTerminator</em> token from its characters.</p>
<pre><code>/*
 * /*
 *  *
 *  */
 */
</code></pre>
<p><strong>Syntax</strong></p>
<ul>
    <i>Comment</i> ::
    <ul>
        <b>//</b> <i>SingleLineCommentCharacters</i><br>
        <i>MultiLineComment</i>
    </ul>
</ul>
<ul>
    <i>SingleLineCommentCharacters</i> ::
    <ul>
        <i>SingleLineCommentCharacter</i> <i>SingleLineCommentCharacters</i><sub>opt</sub>
    </ul>
</ul>
<ul>
    <i>SingleLineCommentCharacter</i> ::
    <ul>
        [lookahead ∉ { <i>LineTerminator</i> }] <i>SourceCharacter</i>
    </ul>
</ul>
<ul>
    <i>MultiLineComment</i> ::
    <ul>
        <b>/*</b> <i>MultiLineCommentCharacters</i><sub>opt</sub> <b>*/</b>
    </ul>
</ul>
<ul>
    <i>MultiLineCommentCharacters</i> ::
    <ul>
        <i>SourceCharacters</i> [but no embedded sequence <b>/*</b>]<br>
        <i>MultiLineComment</i><br>
        <i>MultiLineCommentCharacters</i> <i>SourceCharacters</i> [but no embedded sequence <b>/*</b>]<br>
        <i>MultiLineCommentCharacters</i> <i>MultiLineComment</i>
    </ul>
</ul>
<h2 id="virtual-semicolon"><a class="header" href="#virtual-semicolon">Virtual Semicolon</a></h2>
<p>The <em>VirtualSemicolon</em> nonterminal matches an automatically inserted semicolon, known as a <em>virtual</em> semicolon.</p>
<p>Virtual semicolons are inserted in the following occasions:</p>
<ul>
<li>After a right-curly character <strong>}</strong></li>
<li>Before a <em>LineTerminator</em></li>
</ul>
<h2 id="identifier"><a class="header" href="#identifier">Identifier</a></h2>
<p>The <em>Identifier</em> symbol is similiar to that from the ECMA-262 third edition, but with support for scalar Unicode escapes.</p>
<p><strong>Syntax</strong></p>
<ul>
    <i>Identifier</i> ::
    <ul>
        <i>IdentifierName</i> [but not <i>ReservedWord</i> or <i>ContextKeyword</i>]<br>
        <i>ContextKeyword</i>
    </ul>
</ul>
<ul>
    <i>IdentifierName</i> ::
    <ul>
        <i>IdentifierStart</i><br>
        <i>IdentifierName</i> <i>IdentifierPart</i>
    </ul>
</ul>
<ul>
    <i>IdentifierStart</i> ::
    <ul>
        <i>UnicodeLetter</i><br>
        underscore <b>_</b><br>
        <b>$</b><br>
        <i>UnicodeEscapeSequence</i>
    </ul>
</ul>
<ul>
    <i>IdentifierPart</i> ::
    <ul>
        <i>UnicodeLetter</i><br>
        <i>UnicodeCombiningMark</i><br>
        <i>UnicodeConnectorPunctuation</i><br>
        <i>UnicodeDigit</i><br>
        underscore <b>_</b><br>
        <b>$</b><br>
        <i>UnicodeEscapeSequence</i>
    </ul>
</ul>
<ul>
    <i>UnicodeLetter</i> ::
    <ul>
        Unicode letter (“L”)<br>
        Unicode letter number (“Nl”)
    </ul>
</ul>
<ul>
    <i>UnicodeDigit</i> ::
    <ul>
        Unicode decimal digit number (“Nd”)
    </ul>
</ul>
<ul>
    <i>UnicodeCombiningMark</i> ::
    <ul>
        Unicode nonspacing mark (“Mn”)<br>
        Unicode spacing combining mark (“Mc”)
    </ul>
</ul>
<ul>
    <i>UnicodeConnectorPunctuation</i> ::
    <ul>
        Unicode connector punctuation (“Pc”)
    </ul>
</ul>
<h2 id="keywords"><a class="header" href="#keywords">Keywords</a></h2>
<p><em>ReservedWord</em> includes the following reserved words:</p>
<pre><code class="language-plain">as
do
if
in
is

for
new
not
try
use
var

case
else
null
this
true
void
with

await
break
catch
class
const
false
super
throw
while
yield

delete
import
public
return
switch
typeof

default
extends
finally
package
private

continue
function
internal

interface
protected

implements
</code></pre>
<p><em>ContextKeyword</em> is one of the following in certain syntactic contexts:</p>
<pre><code class="language-plain">get
set

each
enum
type

Embed
final

native
static

abstract
override

namespace
</code></pre>
<h2 id="punctuator"><a class="header" href="#punctuator">Punctuator</a></h2>
<p><em>Punctuator</em> includes one of the following:</p>
<pre><code class="language-plain">::  @
.  ..  ...
(  )  [  ]  {  }
:  ;  ,
?  !  =
?.
&lt;  &lt;=
&gt;  &gt;=
==  ===
!=  !==
+  -  *  %  **
++  --
&lt;&lt;  &gt;&gt;  &gt;&gt;&gt;
&amp;  ^  |  ~
&amp;&amp;  ^^  ||  ??
</code></pre>
<p>The <code>@</code> punctuator must not be followed by a single quote <b>'</b> or a double quote character <b>"</b>.</p>
<p><em>Punctuator</em> includes <em>CompoundAssignmentPunctuator</em>. <em>CompoundAssignmentPunctuator</em> is one of the following:</p>
<pre><code class="language-plain">+=  -=  *=  %=  **=
&lt;&lt;=  &gt;&gt;=  &gt;&gt;&gt;=  &amp;=  ^=  |=
&amp;&amp;=  ^^=  ||=
??=
</code></pre>
<h2 id="numeric-literal"><a class="header" href="#numeric-literal">Numeric Literal</a></h2>
<p><em>NumericLiteral</em> is similiar to <em>NumericLiteral</em> from the ECMA-262 third edition, with support for binary literals and underscore separators:</p>
<pre><code class="language-plain">0b1011
1_000
</code></pre>
<p><strong>Syntax</strong></p>
<ul>
    <i>NumericLiteral</i> ::
    <ul>
        <i>DecimalLiteral</i> [lookahead ∉ { <i>IdentifierStart</i>, <i>DecimalDigit</i> }]<br>
        <i>HexIntegerLiteral</i> [lookahead ∉ { <i>IdentifierStart</i>, <i>DecimalDigit</i> }]<br>
        <i>BinIntegerLiteral</i> [lookahead ∉ { <i>IdentifierStart</i>, <i>DecimalDigit</i> }]
    </ul>
</ul>
<ul>
    <i>DecimalLiteral</i> ::
    <ul>
        <i>DecimalIntegerLiteral</i> <b>.</b> <i>UnderscoreDecimalDigits</i><sub>opt</sub><br> <i>ExponentPart</i><sub>opt</sub><br>
        <b>.</b> <i>UnderscoreDecimalDigits</i> <i>ExponentPart</i><sub>opt</sub><br>
        <i>DecimalIntegerLiteral</i> <i>ExponentPart</i><sub>opt</sub>
    </ul>
</ul>
<ul>
    <i>DecimalIntegerLiteral</i> ::
    <ul>
        <b>0</b><br>
        [lookahead = <i>NonZeroDigit</i>] <i>UnderscoreDecimalDigits</i><sub>opt</sub>
    </ul>
</ul>
<ul>
    <i>DecimalDigits</i> ::
    <ul>
        <i>DecimalDigit</i><sub>{1,}</sub>
    </ul>
</ul>
<ul>
    <i>UnderscoreDecimalDigits</i> ::
    <ul>
        <i>DecimalDigits</i>
        <i>UnderscoreDecimalDigits</i> <b>_</b> <i>DecimalDigits</i>
    </ul>
</ul>
<ul>
    <i>DecimalDigit</i> ::
    <ul>
        <b>0</b>-<b>9</b>
    </ul>
</ul>
<ul>
    <i>NonZeroDigit</i> ::
    <ul>
        <b>1</b>-<b>9</b>
    </ul>
</ul>
<ul>
    <i>ExponentPart</i> ::
    <ul>
        <i>ExponentIndicator</i> <i>SignedInteger</i>
    </ul>
</ul>
<ul>
    <i>ExponentIndicator</i> ::
    <ul>
        <b>e</b><br>
        <b>E</b>
    </ul>
</ul>
<ul>
    <i>SignedInteger</i> ::
    <ul>
        <i>UnderscoreDecimalDigits</i><br>
        <b>+</b> <i>UnderscoreDecimalDigits</i><br>
        <b>-</b> <i>UnderscoreDecimalDigits</i>
    </ul>
</ul>
<ul>
    <i>HexIntegerLiteral</i> ::
    <ul>
        <b>0x</b> <i>UnderscoreHexDigits</i><br>
        <b>0X</b> <i>UnderscoreHexDigits</i>
    </ul>
</ul>
<ul>
    <i>HexDigit</i> ::
    <ul>
        <b>0</b>-<b>9</b><br>
        <b>A</b>-<b>F</b><br>
        <b>a</b>-<b>f</b>
    </ul>
</ul>
<ul>
    <i>UnderscoreHexDigits</i> ::
    <ul>
        <i>HexDigit</i><sub>{1,}</sub><br>
        <i>UnderscoreDecimalDigits</i> <b>_</b> <i>HexDigit</i><sub>{1,}</sub>
    </ul>
</ul>
<ul>
    <i>BinIntegerLiteral</i> ::
    <ul>
        <b>0b</b> <i>UnderscoreBinDigits</i><br>
        <b>0B</b> <i>UnderscoreBinDigits</i>
    </ul>
</ul>
<ul>
    <i>BinDigit</i> ::
    <ul>
        <b>0</b><br>
        <b>1</b>
    </ul>
</ul>
<ul>
    <i>UnderscoreBinDigits</i> ::
    <ul>
        <i>BinDigit</i><sub>{1,}</sub><br>
        <i>UnderscoreDecimalDigits</i> <b>_</b> <i>BinDigit</i><sub>{1,}</sub>
    </ul>
</ul>
<h2 id="regular-expression-literal"><a class="header" href="#regular-expression-literal">Regular Expression Literal</a></h2>
<p><em>RegularExpressionLiteral</em> is similiar to <em>RegularExpressionLiteral</em> from the ECMA-262 third edition, with support for line breaks.</p>
<p><strong>Syntax</strong></p>
<ul>
    <i>RegularExpressionLiteral</i> ::
    <ul>
        <b>/</b> <i>RegularExpressionBody</i> <b>/</b> <i>RegularExpressionFlags</i>
    </ul>
</ul>
<ul>
    <i>RegularExpressionBody</i> ::
    <ul>
        <i>RegularExpressionFirstChar</i> <i>RegularExpressionChars</i>
    </ul>
</ul>
<ul>
    <i>RegularExpressionChars</i> ::
    <ul>
        «empty»<br>
        <i>RegularExpressionChars</i> <i>RegularExpressionChar</i>
    </ul>
</ul>
<ul>
    <i>RegularExpressionFirstChar</i> ::
    <ul>
        <i>SourceCharacter</i> [but not <b>*</b> or <b>&#x5C;</b> or <b>/</b>]<br>
        <i>BackslashSequence</i>
    </ul>
</ul>
<ul>
    <i>RegularExpressionChar</i> ::
    <ul>
        <i>SourceCharacter</i> [but not <b>&#x5C;</b> or <b>/</b>]<br>
        <i>BackslashSequence</i>
    </ul>
</ul>
<ul>
    <i>BackslashSequence</i> ::
    <ul>
        <b>&#x5C;</b> <i>SourceCharacter</i>
    </ul>
</ul>
<ul>
    <i>RegularExpressionFlags</i> ::
    <ul>
        «empty»<br>
        <i>RegularExpressionFlags</i> <i>IdentifierPart</i>
    </ul>
</ul>
<h2 id="string-literal"><a class="header" href="#string-literal">String Literal</a></h2>
<p><em>StringLiteral</em> is similiar to the <em>StringLiteral</em> symbol from the ECMA-262 third edition. The following additional features are included:</p>
<ul>
<li>Scalar <em>UnicodeEscapeSequence</em> using the <code>\u{...}</code> form</li>
<li>Triple string literals</li>
<li>Raw string literals using the <code>@</code> prefix</li>
</ul>
<p>Triple string literals use either <code>"""</code> or <code>'''</code> as delimiter and may span multiple lines. The contents of triple string literals are indentation-based, as can be observed in the following program:</p>
<pre><code>const text = """
    foo
    bar
    """
text == "foo\nbar"
</code></pre>
<p>Triple string literals are processed as follows:</p>
<ul>
<li>The first empty line is ignored.</li>
<li>The base indentation of a triple string literal is that of the last string line.</li>
</ul>
<p>Both regular and triple string literals accept the <code>@</code> prefix, designating raw string literals. Raw string literals contain no escape sequences.</p>
<pre><code>const text = @"""
    x\y
    """
</code></pre>
<p>Escape sequences are described by the following table:</p>
<div class="table-wrapper"><table><thead><tr><th>Escape</th><th>Description</th></tr></thead><tbody>
<tr><td>\'</td><td>U+27 single-quote</td></tr>
<tr><td>\"</td><td>U+22 double-quote</td></tr>
<tr><td>\\</td><td>U+5C backslash character</td></tr>
<tr><td>\b</td><td>U+08 backspace character</td></tr>
<tr><td>\f</td><td>U+0C form feed character</td></tr>
<tr><td>\n</td><td>U+0A line feed character</td></tr>
<tr><td>\r</td><td>U+0D carriage return character</td></tr>
<tr><td>\t</td><td>U+09 tab character</td></tr>
<tr><td>\v</td><td>U+0B vertical tab character</td></tr>
<tr><td>\0</td><td>U+00 character</td></tr>
<tr><td>\xHH</td><td>Contributes an Unicode code point value</td></tr>
<tr><td>\uHHHH</td><td>Contributes an Unicode code point value</td></tr>
<tr><td>\u{...}</td><td>Contributes an Unicode code point value</td></tr>
<tr><td>\ followed by <em>LineTerminator</em></td><td>Contributes nothing</td></tr>
</tbody></table>
</div>
<p><strong>Syntax</strong></p>
<ul>
    <i>StringLiteral</i> ::
    <ul>
        [lookahead ≠ <b>"""</b>] <b>"</b> <i>DoubleStringCharacter</i><sub>{0,}</sub> <b>"</b><br>
        [lookahead ≠ <b>'''</b>] <b>'</b> <i>SingleStringCharacter</i><sub>{0,}</sub> <b>'</b><br>
        <b>"""</b> <i>TripleDoubleStringCharacter</i><sub>{0,}</sub> <b>"""</b><br>
        <b>'''</b> <i>TripleSingleStringCharacter</i><sub>{0,}</sub> <b>'''</b><br>
        <i>RawStringLiteral</i>
    </ul>
</ul>
<ul>
    <i>RawStringLiteral</i> ::
    <ul>
        <b>@</b> [lookahead ≠ <b>"""</b>] <b>"</b> <i>DoubleStringRawCharacter</i><sub>{0,}</sub> <b>"</b><br>
        <b>@</b> [lookahead ≠ <b>'''</b>] <b>'</b> <i>SingleStringRawCharacter</i><sub>{0,}</sub> <b>'</b><br>
        <b>@"""</b> <i>TripleDoubleStringRawCharacter</i><sub>{0,}</sub> <b>"""</b><br>
        <b>@'''</b> <i>TripleSingleStringRawCharacter</i><sub>{0,}</sub> <b>'''</b>
    </ul>
</ul>
<ul>
    <i>DoubleStringCharacter</i> ::
    <ul>
        <i>SourceCharacter</i> [but not double-quote <b>"</b> or backslash <b>&#x5C;</b> or <i>LineTerminator</i>]<br>
        <i>EscapeSequence</i>
    </ul>
</ul>
<ul>
    <i>SingleStringCharacter</i> ::
    <ul>
        <i>SourceCharacter</i> [but not single-quote <b>'</b> or backslash <b>&#x5C;</b> or <i>LineTerminator</i>]<br>
        <i>EscapeSequence</i>
    </ul>
</ul>
<ul>
    <i>DoubleStringRawCharacter</i> ::
    <ul>
        <i>SourceCharacter</i> [but not double-quote <b>"</b> or <i>LineTerminator</i>]
    </ul>
</ul>
<ul>
    <i>SingleStringRawCharacter</i> ::
    <ul>
        <i>SourceCharacter</i> [but not single-quote <b>'</b> or <i>LineTerminator</i>]
    </ul>
</ul>
<ul>
    <i>TripleDoubleStringCharacter</i> ::
    <ul>
        [lookahead ≠ <b>"""</b>] <i>SourceCharacter</i> [but not backslash <b>&#x5C;</b> or <i>LineTerminator</i>]<br>
        <i>EscapeSequence</i><br>
        <i>LineTerminator</i>
    </ul>
</ul>
<ul>
    <i>TripleSingleStringCharacter</i> ::
    <ul>
        [lookahead ≠ <b>'''</b>] <i>SourceCharacter</i> [but not backslash <b>&#x5C;</b> or <i>LineTerminator</i>]<br>
        <i>EscapeSequence</i><br>
        <i>LineTerminator</i>
    </ul>
</ul>
<ul>
    <i>TripleDoubleStringRawCharacter</i> ::
    <ul>
        [lookahead ≠ <b>"""</b>] <i>SourceCharacter</i> [but not <i>LineTerminator</i>]<br>
        <i>LineTerminator</i>
    </ul>
</ul>
<ul>
    <i>TripleSingleStringRawCharacter</i> ::
    <ul>
        [lookahead ≠ <b>'''</b>] <i>SourceCharacter</i> [but not <i>LineTerminator</i>]<br>
        <i>LineTerminator</i>
    </ul>
</ul>
<h2 id="escape-sequences"><a class="header" href="#escape-sequences">Escape Sequences</a></h2>
<p><strong>Syntax</strong></p>
<ul>
    <i>EscapeSequence</i> ::
    <ul>
        <b>&#x5C;</b> <i>CharacterEscapeSequence</i><br>
        <b>&#x5C;0</b> [lookahead ∉ <i>DecimalDigit</i>]<br>
        <b>&#x5C;</b> <i>LineTerminator</i><br>
        <i>HexEscapeSequence</i><br>
        <i>UnicodeEscapeSequence</i>
    </ul>
</ul>
<ul>
    <i>CharacterEscapeSequence</i> ::
    <ul>
        <i>SingleEscapeCharacter</i><br>
        <i>NonEscapeCharacter</i>
    </ul>
</ul>
<ul>
    <i>SingleEscapeCharacter</i> ::
    <ul>
        <b>'</b><br>
        <b>"</b><br>
        <b>&#x5C;</b><br>
        <b>b</b><br>
        <b>f</b><br>
        <b>n</b><br>
        <b>r</b><br>
        <b>t</b><br>
        <b>v</b>
    </ul>
</ul>
<ul>
    <i>NonEscapeCharacter</i> ::
    <ul>
        <i>SourceCharacter</i> [but not <i>EscapeCharacter</i> or <i>LineTerminator</i>]
    </ul>
</ul>
<ul>
    <i>EscapeCharacter</i> ::
    <ul>
        <i>SingleEscapeCharacter</i><br>
        <i>DecimalDigit</i><br>
        <b>x</b><br>
        <b>u</b>
    </ul>
</ul>
<ul>
    <i>HexEscapeSequence</i> ::
    <ul>
        <b>&#x5C;x</b> <i>HexDigit</i> <i>HexDigit</i>
    </ul>
</ul>
<ul>
    <i>UnicodeEscapeSequence</i> ::
    <ul>
        <b>&#x5c;u</b> <i>HexDigit</i><sub>{4}</sub><br>
        <b>&#x5c;u</b> <b>&#x7b;</b> <i>HexDigit</i><sub>{1,}</sub> <b>&#x7d;</b>
    </ul>
</ul>
<h2 id="xml"><a class="header" href="#xml">XML</a></h2>
<p>This section defines nonterminals used in the lexical grammar as part of the XML capabilities of the ShockScript language.</p>
<p>If a <em>XMLMarkup</em>, <em>XMLAttributeValue</em> or <em>XMLText</em> contains a <em>LineTerminator</em> after parsed, it contributes such <em>LineTerminator</em> to the lexical scanner.</p>
<p><strong>Syntax</strong></p>
<ul>
    <i>XMLMarkup</i> ::
    <ul>
        <i>XMLComment</i><br>
        <i>XMLCDATA</i><br>
        <i>XMLPI</i><br>
    </ul>
</ul>
<ul>
    <i>XMLWhitespaceCharacter</i> ::
    <ul>
        U+20 space<br>
        U+09 tab<br>
        U+0D carriage return<br>
        U+0A line feed
    </ul>
</ul>
<ul>
    <i>XMLWhitespace</i> ::
    <ul>
        <i>XMLWhitespaceCharacter</i><br>
        <i>XMLWhitespace</i> <i>XMLWhitespaceCharacter</i>
    </ul>
</ul>
<ul>
    <i>XMLText</i> ::
    <ul>
        <i>SourceCharacters</i> [but no embedded left-curly <b>&#x7B;</b> or less-than <b>&lt;</b>]
    </ul>
</ul>
<ul>
    <i>XMLName</i> ::
    <ul>
        <i>XMLNameStart</i><br>
        <i>XMLName</i> <i>XMLNamePart</i>
    </ul>
</ul>
<ul>
    <i>XMLNameStart</i> ::
    <ul>
        <i>UnicodeLetter</i><br>
        underscore <b>_</b><br>
        colon <b>:</b>
    </ul>
</ul>
<ul>
    <i>XMLNamePart</i> ::
    <ul>
        <i>UnicodeLetter</i><br>
        <i>UnicodeDigit</i><br>
        period <b>.</b><br>
        hyphen <b>-</b><br>
        underscore <b>_</b><br>
        colon <b>:</b>
    </ul>
</ul>
<ul>
    <i>XMLComment</i> ::
    <ul>
        <b>&lt;!--</b> <i>XMLCommentCharacters</i><sub>opt</sub> <b>--&gt;</b>
    </ul>
</ul>
<ul>
    <i>XMLCommentCharacters</i> ::
    <ul>
        <i>SourceCharacters</i> [but no embedded sequence <b>--&gt;</b>]
    </ul>
</ul>
<ul>
    <i>XMLCDATA</i> ::
    <ul>
        <b>&lt;![CDATA[</b> <i>XMLCDATACharacters</i> <b>]]&gt;</b>
    </ul>
</ul>
<ul>
    <i>XMLCDATACharacters</i> ::
    <ul>
        <i>SourceCharacters</i> [but no embedded sequence <b>&#x5D;&#x5D;&gt;</b>]
    </ul>
</ul>
<ul>
    <i>XMLPI</i> ::
    <ul>
        <b>&lt;?</b> <i>XMLPICharacters</i><sub>opt</sub> <b>?&gt;</b>
    </ul>
</ul>
<ul>
    <i>XMLPICharacters</i> ::
    <ul>
        <i>SourceCharacters</i> [but no embedded sequence <b>?&gt;</b>]
    </ul>
</ul>
<ul>
    <i>XMLAttributeValue</i> ::
    <ul>
        <b>"</b> <i>XMLDoubleStringCharacters</i><sub>opt</sub> <b>"</b><br>
        <b>'</b> <i>XMLSingleStringCharacters</i><sub>opt</sub> <b>'</b>
    </ul>
</ul>
<ul>
    <i>XMLDoubleStringCharacters</i> ::
    <ul>
        <i>SourceCharacters</i> [but no embedded double-quote <b>"</b>]
    </ul>
</ul>
<ul>
    <i>XMLSingleStringCharacters</i> ::
    <ul>
        <i>SourceCharacters</i> [but no embedded single-quote <b>'</b>]
    </ul>
</ul>
<ul>
    <i>XMLTagPunctuator</i> ::
    <ul>
        <b>=</b><br>
        <b>&amp;=</b><br>
        <b>&gt;</b><br>
        <b>/&gt;</b>
    </ul>
</ul><div style="break-before: page; page-break-before: always;"></div><h1 id="shockscript-expressions"><a class="header" href="#shockscript-expressions">ShockScript: Expressions</a></h1>
<p>The syntactic grammar for expressions declares the <strong>β</strong> superscript, which denotes a pair of definitions: <strong>allowIn</strong> and <strong>noIn</strong>.</p>
<div style="break-before: page; page-break-before: always;"></div><h1 id="identifiers"><a class="header" href="#identifiers">Identifiers</a></h1>
<p><strong>Syntax</strong></p>
<pre><code>x
*
q::x
q::[k]     ;
(q)::x     ;
(q)::[k]   ;
@x
@[k]
@q::x
@q::[k]
@(q)::x
@(q)::[k]
</code></pre>
<ul>
    <i>PropertyIdentifier</i> :
    <ul>
        <i>Identifier</i> [when keywords are enabled]<br>
        <i>IdentifierName</i> [when keywords are disabled]<br>
        <b>*</b>
    </ul>
</ul>
<ul>
    <i>Qualifier</i> :
    <ul>
        <i>PropertyIdentifier</i><br>
        <i>ReservedNamespace</i>
    </ul>
</ul>
<ul>
    <i>ReservedNamespace</i> :
    <ul>
        <b>public</b><br>
        <b>private</b><br>
        <b>protected</b><br>
        <b>internal</b>
    </ul>
</ul>
<ul>
    <i>SimpleQualifiedIdentifier</i> :
    <ul>
        <i>PropertyIdentifier</i><br>
        <i>Qualifier</i> <b>::</b> <i>PropertyIdentifier</i><br>
        <i>Qualifier</i> <b>::</b> <i>Brackets</i>
    </ul>
</ul>
<ul>
    <i>ExpressionQualifiedIdentifier</i> :
    <ul>
        <i>ParenExpression</i> <b>::</b> <i>PropertyIdentifier</i><br>
        <i>ParenExpression</i> <b>::</b> <i>Brackets</i>
    </ul>
</ul>
<ul>
    <i>NonAttributeQualifiedIdentifier</i> :
    <ul>
        <i>SimpleQualifiedIdentifier</i><br>
        <i>ExpressionQualifiedIdentifier</i>
    </ul>
</ul>
<ul>
    <i>QualifiedIdentifier</i> :
    <ul>
        <b>@</b> <i>Brackets</i><br>
        <b>@</b> <i>NonAttributeQualifiedIdentifier</i><br>
        <i>NonAttributeQualifiedIdentifier</i>
    </ul>
</ul><div style="break-before: page; page-break-before: always;"></div><h1 id="primary-expressions"><a class="header" href="#primary-expressions">Primary expressions</a></h1>
<p><strong>Syntax</strong></p>
<ul>
    <i>PrimaryExpression</i> :
    <ul>
        <i>NullLiteral</i><br>
        <i>BooleanLiteral</i><br>
        <i>NumericLiteral</i><br>
        <i>StringLiteral</i><br>
        <i>ThisLiteral</i><br>
        <i>AllLiteral</i><br>
        <i>RegularExpressionLiteral</i><br>
        <i>QualifiedIdentifier</i><br>
        <i>XMLLiteral</i><br>
        <i>FixedExpression</i><br>
        <i>ParenListExpression</i><br>
        <i>ArrayLiteral</i><br>
        <i>ObjectLiteral</i><br>
        <i>EmbedExpression</i>
    </ul>
</ul><div style="break-before: page; page-break-before: always;"></div><h1 id="null-literal"><a class="header" href="#null-literal">Null literal</a></h1>
<p><strong>Syntax</strong></p>
<ul>
    <i>NullLiteral</i> :
    <ul>
        <b>null</b>
    </ul>
</ul><div style="break-before: page; page-break-before: always;"></div><h1 id="this-literal"><a class="header" href="#this-literal">This literal</a></h1>
<p><strong>Syntax</strong></p>
<ul>
    <i>ThisLiteral</i> :
    <ul>
        <b>this</b>
    </ul>
</ul><div style="break-before: page; page-break-before: always;"></div><h1 id="all-literal"><a class="header" href="#all-literal">All literal</a></h1>
<p><strong>Syntax</strong></p>
<pre><code>**
</code></pre>
<ul>
    <i>AllLiteral</i> :
    <ul>
        <b>**</b>
    </ul>
</ul>
<p><strong>Semantics</strong></p>
<p>The <em>all literal</em> returns a value of a <code>Flags</code> enumeration filled with the all flags from that <code>Flags</code> enumeration. The context type must be a <code>Flags</code> enumeration.</p>
<div style="break-before: page; page-break-before: always;"></div><h1 id="boolean-literal"><a class="header" href="#boolean-literal">Boolean literal</a></h1>
<p><strong>Syntax</strong></p>
<ul>
    <i>BooleanLiteral</i> :
    <ul>
        <b>true</b><br>
        <b>false</b>
    </ul>
</ul><div style="break-before: page; page-break-before: always;"></div><h1 id="numeric-literal-1"><a class="header" href="#numeric-literal-1">Numeric literal</a></h1>
<p><strong>Syntax</strong></p>
<pre><code>10
10.0
.0
10e5
1e+9
1e-9
0b1011
0xFF
10_000
</code></pre>
<div style="break-before: page; page-break-before: always;"></div><h1 id="string-literal-1"><a class="header" href="#string-literal-1">String literal</a></h1>
<p><strong>Syntax</strong></p>
<pre><code>"shockscript"
</code></pre>
<p>Triple string literals span multiple lines and are indentation-aware:</p>
<pre><code>(
    """
    shockscript, nicely beauty
    scripting.
    """
) == "shockscript, nicely beauty\nscripting."
</code></pre>
<div style="break-before: page; page-break-before: always;"></div><h1 id="regular-expression-literal-1"><a class="header" href="#regular-expression-literal-1">Regular expression literal</a></h1>
<p><strong>Syntax</strong></p>
<pre><code>/(?:)/gi
</code></pre>
<div style="break-before: page; page-break-before: always;"></div><h1 id="xml-literal"><a class="header" href="#xml-literal">XML literal</a></h1>
<p><strong>Syntax</strong></p>
<ul>
    <i>XMLLiteral</i> :
    <ul>
        <i>XMLMarkup</i><br>
        <i>XMLElement</i><br>
        <b>&lt;</b> <b>&gt;</b> <i>XMLElementContent</i> <b>&lt;/</b> <b>&gt;</b>
    </ul>
</ul>
<ul>
    <i>XMLElement</i> :
    <ul>
        <b>&lt;</b> <i>XMLTagContent</i> <i>XMLWhitespace</i><sub>opt</sub> <b>/&gt;</b><br>
        <b>&lt;</b> <i>XMLTagContent</i> <i>XMLWhitespace</i><sub>opt</sub> <b>&gt;</b> <i>XMLElementContent</i> <b>&lt;/</b> <i>XMLTagName</i> <i>XMLWhitespace</i><sub>opt</sub> <b>&gt;</b>
    </ul>
</ul>
<ul>
    <i>XMLTagContent</i> :
    <ul>
        <i>XMLTagName</i> <i>XMLAttributes</i>
    </ul>
</ul>
<ul>
    <i>XMLTagName</i> :
    <ul>
        <b>{</b> <i>AssignmentExpression</i><sup>allowIn</sup> <b>}</b><br>
        <i>XMLName</i>
    </ul>
</ul>
<ul>
    <i>XMLAttributes</i> :
    <ul>
        <i>XMLWhitespace</i> <b>{</b> <i>AssignmentExpression</i><sup>allowIn</sup> <b>}</b><br>
        <i>XMLAttribute</i> <i>XMLAttributes</i><br>
        «empty»
    </ul>
</ul>
<ul>
    <i>XMLAttribute</i> :
    <ul>
        <i>XMLWhitespace</i> <i>XMLName</i> [lookahead ≠ <i>XMLWhitespace</i><sub>opt</sub> <b>=</b> ] [lookahead ≠ <i>XMLWhitespace</i><sub>opt</sub> <b>&amp;=</b> ]<br>
        <i>XMLWhitespace</i> <i>XMLName</i> <i>XMLWhitespace</i><sub>opt</sub> <b>=</b> <i>XMLWhitespace</i><sub>opt</sub> <b>{</b> <i>AssignmentExpression</i><sup>allowIn</sup> <b>}</b><br>
        <i>XMLWhitespace</i> <i>XMLName</i> <i>XMLWhitespace</i><sub>opt</sub> <b>&amp;=</b> <i>XMLWhitespace</i><sub>opt</sub> <i>Block</i><br>
        <i>XMLWhitespace</i> <i>XMLName</i> <i>XMLWhitespace</i><sub>opt</sub> <b>=</b> <i>XMLWhitespace</i><sub>opt</sub> <i>XMLAttributeValue</i>
    </ul>
</ul>
<ul>
    <i>XMLElementContent</i> :
    <ul>
        <b>{</b> <i>AssignmentExpression</i><sup>allowIn</sup> <b>}</b> <i>XMLElementContent</i><br>
        <i>XMLMarkup</i> <i>XMLElementContent</i><br>
        <i>XMLText</i> <i>XMLElementContent</i><br>
        <i>XMLElement</i> <i>XMLElementContent</i><br>
        «empty»
    </ul>
</ul><div style="break-before: page; page-break-before: always;"></div><h1 id="array-literal"><a class="header" href="#array-literal">Array literal</a></h1>
<p><strong>Syntax</strong></p>
<pre><code>["shock", "script"]
</code></pre>
<ul>
    <i>ArrayLiteral</i> :
    <ul>
        <b>[</b> <i>Elision</i><sub>opt</sub> <b>]</b><br>
        <b>[</b> <i>ElementList</i> <b>]</b><br>
        <b>[</b> <i>ElementList</i> <b>,</b> <i>Elision</i><sub>opt</sub> <b>]</b>
    </ul>
</ul>
<ul>
    <i>Elision</i> :
    <ul>
        <b>,</b><br>
        <i>Elision</i> <b>,</b>
    </ul>
</ul>
<ul>
    <i>ElementList</i> :
    <ul>
        <i>Elision</i><sub>opt</sub> <i>AssignmentExpression</i><sup>allowIn</sup><br>
        <i>Elision</i><sub>opt</sub> <i>LiteralRest</i><br>
        <i>ElementList</i> <b>,</b> <i>Elision</i><sub>opt</sub> <i>AssignmentExpression</i><sup>allowIn</sup><br>
        <i>ElementList</i> <b>,</b> <i>Elision</i><sub>opt</sub> <i>LiteralRest</i>
    </ul>
</ul><div style="break-before: page; page-break-before: always;"></div><h1 id="object-literal"><a class="header" href="#object-literal">Object literal</a></h1>
<p><strong>Syntax</strong></p>
<ul>
    <i>ObjectLiteral</i> :
    <ul>
        <b>{</b> <i>FieldList</i> <b>}</b>
    </ul>
</ul>
<ul>
    <i>FieldList</i> :
    <ul>
        «empty»<br>
        <i>NonEmptyFieldList</i><br>
        <i>NonEmptyFieldList</i> <b>,</b>
    </ul>
</ul>
<ul>
    <i>NonEmptyFieldList</i> :
    <ul>
        <i>LiteralField</i><br>
        <i>LiteralRest</i><br>
        <i>NonEmptyFieldList</i> <b>,</b> <i>LiteralField</i><br>
        <i>NonEmptyFieldList</i> <b>,</b> <i>LiteralRest</i>
    </ul>
</ul>
<ul>
    <i>LiteralRest</i> :
    <ul>
        <b>...</b> <i>AssignmentExpression</i><sup>allowIn</sup>
    </ul>
</ul>
<ul>
    <i>LiteralField</i> :
    <ul>
        <i>FieldName</i> <b>:</b> <i>AssignmentExpression</i><sup>allowIn</sup><br>
        <i>NonAttributeQualifiedIdentifier</i>
    </ul>
</ul>
<ul>
    <i>FieldName</i> :
    <ul>
        <i>NonAttributeQualifiedIdentifier</i><br>
        <i>Brackets</i><br>
        <i>StringLiteral</i><br>
        <i>NumericLiteral</i>
    </ul>
</ul><div style="break-before: page; page-break-before: always;"></div><h1 id="embed-expression"><a class="header" href="#embed-expression">Embed expression</a></h1>
<p><strong>Syntax</strong></p>
<pre><code>Embed("flower.webp")

// UTF-8 text
Embed("data.txt", "text/plain")

// ByteArray
Embed("data.bin", "application/octet-stream")
</code></pre>
<ul>
    <i>EmbedExpression</i> :
    <ul>
        <b>Embed &#x28;</b> <i>MetadataEntryList</i><sub>opt</sub> <b>&#x29;</b>
    </ul>
</ul>
<p><strong>Semantics</strong></p>
<p>The default form of the embed expression specifying solely a path is implementation-defined, but always returns a <code>String</code> representing an URL.</p>
<p>The form that specifies a path followed by a <code>"text/plain"</code> option will embed the referenced file at the program's static memory as an UTF-8 encoded text, returning the <code>String</code> data type.</p>
<p>The form that specifies a path followed by a <code>"application/octet-stream"</code> option will embed the referenced file at the program's static memory as an octet stream, returning the <code>ByteArray</code> data type.</p>
<div style="break-before: page; page-break-before: always;"></div><h1 id="fixed-expression"><a class="header" href="#fixed-expression">Fixed expression</a></h1>
<p><strong>Syntax</strong></p>
<pre><code>&lt;?fixed={x}?&gt;
</code></pre>
<ul>
    <i>FixedExpression</i> :
    <ul>
        <b>&lt;?fixed=&#x7b;</b> <i>ListExpression</i><sup>allowIn</sup> <b>&#x7d;</b> <b>?&gt;</b>
    </ul>
</ul>
<p><strong>Semantics</strong></p>
<p>Deactivates lookup of dynamic properties (implemented through a <code>shock_proxy</code> proxy such as <code>shock_proxy::get(k)</code> where <code>k</code> includes <code>String</code> or <code>QName</code>) in the enclosed expression.</p>
<blockquote>
<p><strong>Note</strong>: This is necessary in rare cases where, for example, a class implements its own dynamic properties which may collide with its prototype. In such cases, instance variables are not accessible unless the user uses the fixed expression <code>&lt;?fixed={exp}?&gt;</code>. In the case of <code>this</code>, the fixed expression is not necessary as in-scope lookup always uses fixed name lookup.</p>
</blockquote>
<p>The fixed name lookup effect is propagated:</p>
<ul>
<li>From parenthesized expressions to the inner expression</li>
<li>From dot operator to base expression</li>
<li>From brackets operator to base expression</li>
</ul>
<div style="break-before: page; page-break-before: always;"></div><h1 id="parenthesized-expressions"><a class="header" href="#parenthesized-expressions">Parenthesized expressions</a></h1>
<p><strong>Syntax</strong></p>
<pre><code>(x)
</code></pre>
<ul>
    <i>ParenExpression</i> :
    <ul>
        <b>(</b> <i>AssignmentExpression</i><sup>allowIn</sup> <b>)</b>
    </ul>
</ul>
<ul>
    <i>ParenListExpression</i> :
    <ul>
        <i>ParenExpression</i><br>
        <b>(</b> <i>ListExpression</i><sup>allowIn</sup> <b>,</b> <i>AssignmentExpression</i><sup>allowIn</sup> <b>)</b>
    </ul>
</ul><div style="break-before: page; page-break-before: always;"></div><h1 id="super-expression"><a class="header" href="#super-expression">Super expression</a></h1>
<p><strong>Syntax</strong></p>
<ul>
    <i>SuperExpression</i> :
    <ul>
        <b>super</b><br>
        <b>super</b> <i>Arguments</i>
    </ul>
</ul><div style="break-before: page; page-break-before: always;"></div><h1 id="postfix-expressions"><a class="header" href="#postfix-expressions">Postfix expressions</a></h1>
<p><strong>Syntax</strong></p>
<ul>
    <i>PostfixExpression</i> :
    <ul>
        <i>FullPostfixExpression</i><br>
        <i>ShortNewExpression</i>
    </ul>
</ul>
<ul>
    <i>FullPostfixExpression</i> :
    <ul>
        <i>PrimaryExpression</i><br>
        <i>FullNewExpression</i><br>
        <i>FullPostfixExpression</i> <i>PropertyOperator</i><br>
        <i>SuperExpression</i> <i>PropertyOperator</i><br>
        <i>FullPostfixExpression</i> <i>NonNull</i><br>
        <i>FullPostfixExpression</i> <i>Arguments</i><br>
        <i>FullPostfixExpression</i> <i>TypeArguments</i><br>
        <i>FullPostfixExpression</i> <i>QueryOperator</i><br>
        <i>FullPostfixExpression</i> [no line break] <b>++</b><br>
        <i>FullPostfixExpression</i> [no line break] <b>--</b><br>
        <i>FullPostfixExpression</i> <i>OptionalChaining</i>
    </ul>
</ul>
<ul>
    <i>NonNull</i> :
    <ul>
        <b>!</b>
    </ul>
</ul>
<ul>
    <i>OptionalChaining</i> :
    <ul>
        <b>?.</b> <i>QualifiedIdentifier</i><br>
        <b>?.</b> <i>Brackets</i><br>
        <b>?.</b> <i>Arguments</i><br>
        <i>OptionalChaining</i> <i>PropertyOperator</i><br>
        <i>OptionalChaining</i> <i>NonNull</i><br>
        <i>OptionalChaining</i> <i>Arguments</i><br>
        <i>OptionalChaining</i> <i>TypeArguments</i><br>
        <i>OptionalChaining</i> <i>QueryOperator</i><br>
        <i>OptionalChaining</i> <i>OptionalChaining</i>
    </ul>
</ul><div style="break-before: page; page-break-before: always;"></div><h1 id="property-accessors"><a class="header" href="#property-accessors">Property accessors</a></h1>
<p><strong>Syntax</strong></p>
<ul>
    <i>PropertyOperator</i> :
    <ul>
        <b>.</b> <i>QualifiedIdentifier</i><br>
        <i>Brackets</i>
    </ul>
</ul>
<ul>
    <i>Brackets</i> :
    <ul>
        <b>[</b> <i>ListExpression</i><sup>allowIn</sup> <b>]</b>
    </ul>
</ul><div style="break-before: page; page-break-before: always;"></div><h1 id="query-operators"><a class="header" href="#query-operators">Query operators</a></h1>
<p><strong>Syntax</strong></p>
<ul>
    <i>QueryOperator</i> :
    <ul>
        <b>..</b> <i>QualifiedIdentifier</i><br>
        <b>.</b> <b>(</b> <i>ListExpression</i><sup>allowIn</sup> <b>)</b>
    </ul>
</ul>
<h2 id="descendants-operator"><a class="header" href="#descendants-operator">Descendants operator</a></h2>
<pre><code>o..x
</code></pre>
<p><strong>Semantics</strong></p>
<p>The descendants operator <code>o..x</code> looks at <code>o</code> for the <code>shock_proxy::descendants()</code> method and returns the result of invoking that method with the given identifier key.</p>
<h2 id="filter-operator-1"><a class="header" href="#filter-operator-1">Filter operator</a></h2>
<pre><code>o.(*.name.startsWith("A"))
</code></pre>
<p><strong>Semantics</strong></p>
<p>The filter operator <code>o.(...)</code> looks at <code>o</code> for the <code>shock_proxy::filter()</code> method and creates a wildcard <strong>*</strong> binding inside the parenthesized expression that represents the element being tested. The parenthesized expression must return a Boolean and represents an activation.</p>
<div style="break-before: page; page-break-before: always;"></div><h1 id="call-expressions"><a class="header" href="#call-expressions">Call expressions</a></h1>
<p><strong>Syntax</strong></p>
<ul>
    <i>Arguments</i> :
    <ul>
        <b>(</b> <b>)</b><br>
        <b>(</b> <i>ListExpression</i><sup>allowIn</sup> <b>)</b>
    </ul>
</ul>
<ul>
    <i>ArgumentList</i><sup>allowIn</sup> :
    <ul>
        <i>AssignmentExpression</i><sup>β</sup><br>
        <i>ArgumentList</i><sup>β</sup> <b>,</b> <i>AssignmentExpression</i><sup>β</sup>
    </ul>
</ul><div style="break-before: page; page-break-before: always;"></div><h1 id="new-expressions"><a class="header" href="#new-expressions">New expressions</a></h1>
<p><strong>Syntax</strong></p>
<ul>
    <i>FullNewExpression</i> :
    <ul>
        <b>new</b> <i>FullNewSubexpression</i> <i>Arguments</i>
    </ul>
</ul>
<ul>
    <i>FullNewSubexpression</i> :
    <ul>
        <i>PrimaryExpression</i><br>
        <i>FullNewExpression</i><br>
        <i>FullNewSubexpression</i> <i>PropertyOperator</i><br>
        <i>SuperExpression</i> <i>PropertyOperator</i>
    </ul>
</ul>
<ul>
    <i>ShortNewExpression</i> :
    <ul>
        <b>new</b> <i>ShortNewSubexpression</i>
    </ul>
</ul>
<ul>
    <i>ShortNewSubexpression</i> :
    <ul>
        <i>FullNewSubexpression</i><br>
        <i>ShortNewExpression</i>
    </ul>
</ul><div style="break-before: page; page-break-before: always;"></div><h1 id="unary-expressions"><a class="header" href="#unary-expressions">Unary expressions</a></h1>
<p><strong>Syntax</strong></p>
<ul>
    <i>UnaryExpression</i> :
    <ul>
        <i>PostfixExpression</i><br>
        <b>delete</b> <i>PostfixExpression</i><br>
        <b>void</b> <i>UnaryExpression</i><br>
        <b>await</b> <i>UnaryExpression</i><br>
        <b>typeof</b> <i>UnaryExpression</i><br>
        <b>++</b> <i>PostfixExpression</i><br>
        <b>--</b> <i>PostfixExpression</i><br>
        <b>+</b> <i>UnaryExpression</i><br>
        <b>-</b> <i>UnaryExpression</i><br>
        <b>~</b> <i>UnaryExpression</i><br>
        <b>!</b> <i>UnaryExpression</i>
    </ul>
</ul><div style="break-before: page; page-break-before: always;"></div><h1 id="binary-expressions"><a class="header" href="#binary-expressions">Binary expressions</a></h1>
<p>The binary operators are left-associative, excluding the following cases:</p>
<ul>
<li>The exponentiation operator <strong>**</strong> is right-associative.</li>
</ul>
<p>The short circuit operators (<strong>||</strong>, <strong>^^</strong>) have the lowest precedence and the exponentiation operator (<strong>**</strong>) has the greatest precedence.</p>
<div style="break-before: page; page-break-before: always;"></div><h1 id="exponentiation-expressions"><a class="header" href="#exponentiation-expressions">Exponentiation expressions</a></h1>
<p><strong>Syntax</strong></p>
<ul>
    <i>ExponentiationExpression</i> :
    <ul>
        <i>UnaryExpression</i><br>
        <i>UnaryExpression</i> <b>**</b> <i>ExponentiationExpression</i>
    </ul>
</ul><div style="break-before: page; page-break-before: always;"></div><h1 id="multiplicative-expressions"><a class="header" href="#multiplicative-expressions">Multiplicative expressions</a></h1>
<p><strong>Syntax</strong></p>
<ul>
    <i>MultiplicativeExpression</i> :
    <ul>
        <i>ExponentiationExpression</i><br>
        <i>MultiplicativeExpression</i> <b>*</b> <i>ExponentiationExpression</i><br>
        <i>MultiplicativeExpression</i> <b>/</b> <i>ExponentiationExpression</i><br>
        <i>MultiplicativeExpression</i> <b>%</b> <i>ExponentiationExpression</i>
    </ul>
</ul><div style="break-before: page; page-break-before: always;"></div><h1 id="additive-expressions"><a class="header" href="#additive-expressions">Additive expressions</a></h1>
<p><strong>Syntax</strong></p>
<ul>
    <i>AdditiveExpression</i> :
    <ul>
        <i>MultiplicativeExpression</i><br>
        <i>AdditiveExpression</i> <b>+</b> <i>MultiplicativeExpression</i><br>
        <i>AdditiveExpression</i> <b>-</b> <i>MultiplicativeExpression</i>
    </ul>
</ul><div style="break-before: page; page-break-before: always;"></div><h1 id="shift-expressions"><a class="header" href="#shift-expressions">Shift expressions</a></h1>
<p><strong>Syntax</strong></p>
<ul>
    <i>ShiftExpression</i> :
    <ul>
        <i>AdditiveExpression</i><br>
        <i>ShiftExpression</i> <b>&lt;&lt;</b> <i>AdditiveExpression</i><br>
        <i>ShiftExpression</i> <b>&gt;&gt;</b> <i>AdditiveExpression</i><br>
        <i>ShiftExpression</i> <b>&gt;&gt;&gt;</b> <i>AdditiveExpression</i>
    </ul>
</ul><div style="break-before: page; page-break-before: always;"></div><h1 id="relational-expressions"><a class="header" href="#relational-expressions">Relational expressions</a></h1>
<p><strong>Syntax</strong></p>
<ul>
    <i>RelationalExpression</i><sup>β</sup> :
    <ul>
        <i>ShiftExpression</i><br>
        <i>RelationalExpression</i><sup>β</sup> <b>&gt;</b> <i>ShiftExpression</i><br>
        <i>RelationalExpression</i><sup>β</sup> <b>&lt;</b> <i>ShiftExpression</i><br>
        <i>RelationalExpression</i><sup>β</sup> <b>&lt;=</b> <i>ShiftExpression</i><br>
        <i>RelationalExpression</i><sup>β</sup> <b>&gt;=</b> <i>ShiftExpression</i><br>
        <i>RelationalExpression</i><sup>β</sup> <b>as</b> <i>ShiftExpression</i><br>
        <i>RelationalExpression</i><sup>β</sup> <b>is</b> <i>ShiftExpression</i><br>
        <i>RelationalExpression</i><sup>β</sup> <b>is not</b> <i>ShiftExpression</i><br>
        [β = allowIn] <i>RelationalExpression</i><sup>β</sup> <b>in</b> <i>ShiftExpression</i><br>
        [β = allowIn] <i>RelationalExpression</i><sup>β</sup> <b>not in</b> <i>ShiftExpression</i>
    </ul>
</ul><div style="break-before: page; page-break-before: always;"></div><h1 id="equality-expressions"><a class="header" href="#equality-expressions">Equality expressions</a></h1>
<p><strong>Syntax</strong></p>
<ul>
    <i>EqualityExpression</i><sup>β</sup> :
    <ul>
        <i>RelationalExpression</i><sup>β</sup><br>
        <i>EqualityExpression</i><sup>β</sup> <b>==</b> <i>RelationalExpression</i><sup>β</sup><br>
        <i>EqualityExpression</i><sup>β</sup> <b>!=</b> <i>RelationalExpression</i><sup>β</sup><br>
        <i>EqualityExpression</i><sup>β</sup> <b>===</b> <i>RelationalExpression</i><sup>β</sup><br>
        <i>EqualityExpression</i><sup>β</sup> <b>!==</b> <i>RelationalExpression</i><sup>β</sup>
    </ul>
</ul><div style="break-before: page; page-break-before: always;"></div><h1 id="bitwise-expressions"><a class="header" href="#bitwise-expressions">Bitwise expressions</a></h1>
<p><strong>Syntax</strong></p>
<ul>
    <i>BitwiseAndExpression</i><sup>β</sup> :
    <ul>
        <i>EqualityExpression</i><sup>β</sup><br>
        <i>BitwiseAndExpression</i><sup>β</sup> <b>&amp;</b> <i>EqualityExpression</i><sup>β</sup>
    </ul>
</ul>
<ul>
    <i>BitwiseXorExpression</i><sup>allowIn</sup> :
    <ul>
        <i>BitwiseAndExpression</i><sup>β</sup><br>
        <i>BitwiseXorExpression</i><sup>β</sup> <b>^</b> <i>BitwiseAndExpression</i><sup>β</sup>
    </ul>
</ul>
<ul>
    <i>BitwiseOrExpression</i><sup>allowIn</sup> :
    <ul>
        <i>BitwiseXorExpression</i><sup>β</sup><br>
        <i>BitwiseOrExpression</i><sup>β</sup> <b>|</b> <i>BitwiseXorExpression</i><sup>β</sup>
    </ul>
</ul><div style="break-before: page; page-break-before: always;"></div><h1 id="logical-expressions"><a class="header" href="#logical-expressions">Logical expressions</a></h1>
<p><strong>Syntax</strong></p>
<ul>
    <i>LogicalAndExpression</i><sup>β</sup> :
    <ul>
        <i>BitwiseOrExpression</i><sup>β</sup><br>
        <i>LogicalAndExpression</i><sup>β</sup> <b>&amp;&amp;</b> <i>BitwiseOrExpression</i><sup>β</sup>
    </ul>
</ul>
<ul>
    <i>LogicalXorExpression</i><sup>allowIn</sup> :
    <ul>
        <i>LogicalAndExpression</i><sup>β</sup><br>
        <i>LogicalXorExpression</i><sup>β</sup> <b>^^</b> <i>LogicalAndExpression</i><sup>β</sup>
    </ul>
</ul>
<ul>
    <i>LogicalOrExpression</i><sup>allowIn</sup> :
    <ul>
        <i>LogicalXorExpression</i><sup>β</sup><br>
        <i>LogicalOrExpression</i><sup>β</sup> <b>||</b> <i>LogicalXorExpression</i><sup>β</sup>
    </ul>
</ul><div style="break-before: page; page-break-before: always;"></div><h1 id="coalesce-expression"><a class="header" href="#coalesce-expression">Coalesce expression</a></h1>
<p><strong>Syntax</strong></p>
<ul>
    <i>CoalesceExpression</i><sup>β</sup> :
    <ul>
        <i>CoalesceExpressionHead</i><sup>β</sup> <b>??</b> <i>BitwiseOrExpression</i><sup>β</sup>
    </ul>
</ul>
<ul>
    <i>CoalesceExpressionHead</i><sup>β</sup> :
    <ul>
        <i>CoalesceExpression</i><sup>β</sup><br>
        <i>BitwiseOrExpression</i><sup>β</sup>
    </ul>
</ul><div style="break-before: page; page-break-before: always;"></div><h1 id="short-circuit-expressions"><a class="header" href="#short-circuit-expressions">Short circuit expressions</a></h1>
<p><strong>Syntax</strong></p>
<ul>
    <i>ShortCircuitExpression</i><sup>β</sup> :
    <ul>
        <i>LogicalOrExpression</i><sup>β</sup><br>
        <i>CoalesceExpression</i><sup>β</sup>
    </ul>
</ul><div style="break-before: page; page-break-before: always;"></div><h1 id="conditional-expressions"><a class="header" href="#conditional-expressions">Conditional expressions</a></h1>
<p><strong>Syntax</strong></p>
<ul>
    <i>ConditionalExpression</i><sup>β</sup> :
    <ul>
        <i>ShortCircuitExpression</i><sup>β</sup><br>
        <i>ShortCircuitExpression</i><sup>β</sup> <b>?</b> <i>AssignmentExpression</i><sup>β</sup> <b>:</b> <i>AssignmentExpression</i><sup>β</sup>
    </ul>
</ul><div style="break-before: page; page-break-before: always;"></div><h1 id="non-assignment-expressions"><a class="header" href="#non-assignment-expressions">Non assignment expressions</a></h1>
<p><strong>Syntax</strong></p>
<ul>
    <i>NonAssignmentExpression</i><sup>β</sup> :
    <ul>
        <i>ShortCircuitExpression</i><sup>β</sup><br>
        <b>yield</b> [no line break] <i>NonAssignmentExpression</i><sup>β</sup><br>
        <i>FunctionExpression</i><sup>β</sup><br>
        <i>ShortCircuitExpression</i><sup>β</sup> <b>?</b> <i>NonAssignmentExpression</i><sup>β</sup> <b>:</b> <i>NonAssignmentExpression</i><sup>β</sup>
    </ul>
</ul><div style="break-before: page; page-break-before: always;"></div><h1 id="assignment-expressions"><a class="header" href="#assignment-expressions">Assignment expressions</a></h1>
<p><strong>Syntax</strong></p>
<ul>
    <i>AssignmentExpression</i><sup>β</sup> :
    <ul>
        <i>ConditionalExpression</i><sup>β</sup><br>
        <b>yield</b> [no line break] <i>AssignmentExpression</i><sup>β</sup><br>
        <i>FunctionExpression</i><sup>β</sup><br>
        <i>AssignmentLeftHandSide</i> <b>=</b> <i>AssignmentExpression</i><sup>β</sup><br>
        <i>PostfixExpression</i> <i>CompoundAssignmentPunctuator</i> <i>AssignmentExpression</i><sup>β</sup><br>
        <i>PostfixExpression</i> <n>/=</b> <i>AssignmentExpression</i><sup>β</sup>
    </ul>
</ul>
<ul>
    <i>AssignmentLeftHandSide</i> :
    <ul>
        <i>ArrayPattern</i><br>
        <i>ObjectPattern</i><br>
        <i>PostfixExpression</i> [but not <i>ArrayLiteral</i> or <i>ObjectLiteral</i>]
    </ul>
</ul><div style="break-before: page; page-break-before: always;"></div><h1 id="function-expression"><a class="header" href="#function-expression">Function expression</a></h1>
<p><strong>Syntax</strong></p>
<ul>
    <i>FunctionExpression</i><sup>β</sup> :
    <ul>
        <b>function</b> <i>FunctionCommon</i><sup>β</sup><br>
        <b>function</b> <i>IdentifierName</i> <i>FunctionCommon</i><sup>β</sup>
    </ul>
</ul><div style="break-before: page; page-break-before: always;"></div><h1 id="list-expressions"><a class="header" href="#list-expressions">List expressions</a></h1>
<p><strong>Syntax</strong></p>
<ul>
    <i>ListExpression</i><sup>β</sup> :
    <ul>
        <i>AssignmentExpression</i><sup>β</sup><br>
        <i>ListExpression</i><sup>β</sup> <b>,</b> <i>AssignmentExpression</i><sup>β</sup>
    </ul>
</ul><div style="break-before: page; page-break-before: always;"></div><h1 id="shockscript-type-expressions"><a class="header" href="#shockscript-type-expressions">ShockScript: Type expressions</a></h1>
<p><strong>Syntax</strong></p>
<ul>
    <i>TypeExpression</i> :
    <ul>
        <i>NonPrefixedTypeExpression</i><br>
        <b>?</b> <i>NonPrefixedTypeExpression</i>
    </ul>
</ul>
<ul>
    <i>TypeExpressionList</i> :
    <ul>
        <i>TypeExpression</i><br>
        <i>TypeExpressionList</i> <b>,</b> <i>TypeExpression</i>
    </ul>
</ul>
<ul>
    <i>NonPrefixedTypeExpression</i> :
    <ul>
        <b>*</b><br>
        <b>this</b><br>
        <b>void</b><br>
        <b>null</b><br>
        [lookahead ≠ <b>&#x28;</b> ] <i>QualifiedIdentifier</i><br>
        <b>&#x28;</b> <i>TypeExpression</i> <b>&#x29;</b><br>
        <b>&#x28;</b> <i>TypeExpression</i> <b>,</b> <i>TypeExpressionList</i> <b>&#x29;</b><br>
        <i>TupleTypeExpression</i><br>
        <i>RecordTypeExpression</i><br>
        <i>FunctionTypeExpression</i><br>
        <i>NonPrefixedTypeExpression</i> <i>PropertyOperator</i><br>
        <i>NonPrefixedTypeExpression</i> [lookahead = <b>.</b> ] <i>QueryOperator</i><br>
        <i>NonPrefixedTypeExpression</i> <i>TypeArguments</i><br>
        <i>NonPrefixedTypeExpression</i> <i>NonNull</i><br>
        <i>NonPrefixedTypeExpression</i> <b>?</b>
    </ul>
</ul>
<ul>
    <i>TupleTypeExpression</i> :
    <ul>
        <b>&#x5B;</b> <i>TypeExpression</i> <b>&#x5D;</b><br>
        <b>&#x5B;</b> <i>TypeExpression</i> <b>,</b> <i>TypeExpressionList</i> <b>&#x5D;</b><br>
        <b>&#x5B;</b> <i>TypeExpression</i> <b>,</b> <i>TypeExpressionList</i> <b>,</b> <b>&#x5D;</b>
    </ul>
</ul>
<ul>
    <i>RecordTypeExpression</i> :
    <ul>
        <b>&#x7B;&#x7D;</b><br>
        <b>&#x7B;</b> <i>RecordTypeItemList</i> <b>&#x7D;</b>
    </ul>
</ul>
<ul>
    <i>RecordTypeItemList</i> :
    <ul>
        <i>RecordTypeField</i><br>
        <i>RecordTypeField</i> <b>,</b> <i>RecordTypeItemList</i><br>
        <b>...</b> <i>TypeExpression</i>
    </ul>
</ul>
<ul>
    <i>RecordTypeField</i> :
    <ul>
        <i>NonAttributeQualifiedIdentifier</i> <b>:</b> <i>TypeExpression</i>
    </ul>
</ul>
<ul>
    <i>FunctionTypeExpression</i> :
    <ul>
        <b>function</b> <b>&#x28;</b> <b>&#x29;</b> <b>:</b> <i>TypeExpression</i><br>
        <b>function</b> <b>&#x28;</b> <i>FunctionTypeParameterList</i> <b>&#x29;</b> <b>:</b> <i>TypeExpression</i>
    </ul>
</ul>
<ul>
    <i>FunctionTypeParameterList</i> :
    <ul>
        <i>FunctionTypeParameter</i><br>
        <i>FunctionTypeParameterList</i> <b>,</b> <i>FunctionTypeParameter</i>
    </ul>
</ul>
<ul>
    <i>FunctionTypeParameter</i> :
    <ul>
        <b>...</b> <i>TypeExpression</i><sub>opt</sub><br>
        <i>TypeExpression</i> [lookahead ≠ <b>=</b> ]<br>
        <i>TypeExpression</i> <b>=</b>
    </ul>
</ul>
<ul>
    <i>TypeArguments</i> :
    <ul>
        <b>.</b> <b>&lt;</b> <i>TypeArgumentsList</i> <i>GenericGreaterThan</i>
    </ul>
</ul>
<ul>
    <i>GenericGreaterThan</i> :
    <ul>
        <b>&gt;</b><br>
        first greater-than <b>&gt;</b> from the offending token
    </ul>
</ul>
<ul>
    <i>TypeArgumentsList</i> :
    <ul>
        <i>TypeExpression</i><br>
        <i>TypeArgumentsList</i> <b>,</b> <i>TypeExpression</i>
    </ul>
</ul><div style="break-before: page; page-break-before: always;"></div><h1 id="shockscript-patterns"><a class="header" href="#shockscript-patterns">ShockScript: Patterns</a></h1>
<p>Destructuring patterns may be used in a number of contexts, including variable bindings, <code>try..catch</code> clauses, <code>switch type</code> cases and assignment left-hand sides.</p>
<p>Where applicable, expressions are disambiguated into destructuring patterns, in which case any incompatible or illegal expression results in a syntax error; for example, an expression is disambiguated in a pattern in an assignment whose left-hand side starts with a bracket <strong>[</strong> or a brace <strong>{</strong>.</p>
<p><strong>Syntax</strong></p>
<ul>
    <i>Pattern</i> :
    <ul>
        <i>Identifier</i> [when keywords are enabled]<br>
        <i>IdentifierName</i> [when keywords are disabled]<br>
        <i>ArrayPattern</i><br>
        <i>ObjectPattern</i>
    </ul>
</ul>
<ul>
    <i>TypedPattern</i> :
    <ul>
        <i>Pattern</i> [lookahead ≠ <b>:</b>]<br>
        <i>Pattern</i> <b>:</b> <i>TypeExpression</i>
    </ul>
</ul><div style="break-before: page; page-break-before: always;"></div><h1 id="array-pattern"><a class="header" href="#array-pattern">Array pattern</a></h1>
<p><strong>Syntax</strong></p>
<ul>
    <i>ArrayPattern</i> :
    <ul>
        <b>&#x5B;&#x5D;</b><br>
        <b>&#x5B;</b> <i>ArrayPatternItemList</i> <b>&#x5D;</b>
    </ul>
</ul>
<ul>
    <i>ArrayPatternItemList</i> :
    <ul>
        <b>,</b><br>
        <b>,</b> <i>ArrayPatternItemList</i><br>
        <i>Pattern</i><br>
        <i>Pattern</i> <b>,</b> <i>ArrayPatternItemList</i><br>
        <b>...</b> <i>Pattern</i>
    </ul>
</ul><div style="break-before: page; page-break-before: always;"></div><h1 id="object-pattern"><a class="header" href="#object-pattern">Object pattern</a></h1>
<p><strong>Syntax</strong></p>
<ul>
    <i>ObjectPattern</i> :
    <ul>
        <b>&#x7B;&#x7D;</b><br>
        <b>&#x7B;</b> <i>ObjectPatternFieldList</i> <b>&#x7D;</b>
    </ul>
</ul>
<ul>
    <i>ObjectPatternFieldList</i> :
    <ul>
        <i>ObjectPatternField</i><br>
        <i>ObjectPatternField</i> <b>,</b><br>
        <i>ObjectPatternField</i> <b>,</b> <i>ObjectPatternFieldList</i>
    </ul>
</ul>
<ul>
    <i>ObjectPatternField</i> :
    <ul>
        <i>FieldName</i> <b>:</b> <i>Pattern</i><br>
        <i>NonAttributeQualifiedIdentifier</i>
    </ul>
</ul><div style="break-before: page; page-break-before: always;"></div><h1 id="shockscript-statements"><a class="header" href="#shockscript-statements">ShockScript: Statements</a></h1>
<p>The <strong>ω</strong> superscript used throughout the specification translates to one of { <strong>abbrev</strong>, <strong>noShortIf</strong>, <strong>full</strong> }.</p>
<p><strong>Syntax</strong></p>
<ul>
    <i>Statement</i><sup>ω</sup> :
    <ul>
        <i>SuperStatement</i> <i>Semicolon</i><sup>ω</sup><br>
        <i>Block</i><br>
        <i>IfStatement</i><sup>ω</sup><br>
        <i>SwitchStatement</i><br>
        <i>DoStatement</i> <i>Semicolon</i><sup>ω</sup><br>
        <i>WhileStatement</i><sup>ω</sup><br>
        <i>ForStatement</i><sup>ω</sup><br>
        <i>WithStatement</i><sup>ω</sup><br>
        <i>ContinueStatement</i> <i>Semicolon</i><sup>ω</sup><br>
        <i>BreakStatement</i> <i>Semicolon</i><sup>ω</sup><br>
        <i>ReturnStatement</i> <i>Semicolon</i><sup>ω</sup><br>
        <i>ThrowStatement</i> <i>Semicolon</i><sup>ω</sup><br>
        <i>TryStatement</i><br>
        <i>ExpressionStatement</i> <i>Semicolon</i><sup>ω</sup><br>
        <i>LabeledStatement</i><sup>ω</sup>
    </ul>
</ul>
<ul>
    <i>Substatement</i><sup>ω</sup> :
    <ul>
        <i>EmptyStatement</i><br>
        <i>Statement</i><sup>ω</sup>
    </ul>
</ul>
<ul>
    <i>Substatements</i> :
    <ul>
        «empty»<br>
        <i>SubstatementsPrefix</i> <i>Substatement</i><sup>abbrev</sup>
    </ul>
</ul>
<ul>
    <i>SubstatementsPrefix</i> :
    <ul>
        «empty»<br>
        <i>SubstatementsPrefix</i> <i>Substatement</i><sup>full</sup>
    </ul>
</ul>
<ul>
    <i>Semicolon</i><sup>abbrev</sup> :
    <ul>
        <b>;</b><br>
        <i>VirtualSemicolon</i><br>
        «empty»
    </ul>
</ul>
<ul>
    <i>Semicolon</i><sup>noShortIf</sup> :
    <ul>
        <i>Semicolon</i><sup>abbrev</sup>
    </ul>
</ul>
<ul>
    <i>Semicolon</i><sup>full</sup> :
    <ul>
        <b>;</b><br>
        <i>VirtualSemicolon</i>
    </ul>
</ul><div style="break-before: page; page-break-before: always;"></div><h1 id="empty-statement"><a class="header" href="#empty-statement">Empty statement</a></h1>
<p><strong>Syntax</strong></p>
<ul>
    <i>EmptyStatement</i> :
    <ul>
        <b>;</b>
    </ul>
</ul><div style="break-before: page; page-break-before: always;"></div><h1 id="expression-statement"><a class="header" href="#expression-statement">Expression statement</a></h1>
<p><strong>Syntax</strong></p>
<ul>
    <i>ExpressionStatement</i> :
    <ul>
        [lookahead ∉ { <b>function</b>, <b>&#x7B;</b> }] <i>ListExpression</i><sup>allowIn</sup>
    </ul>
</ul><div style="break-before: page; page-break-before: always;"></div><h1 id="super-statement-1"><a class="header" href="#super-statement-1">Super statement</a></h1>
<p><strong>Syntax</strong></p>
<ul>
    <i>SuperStatement</i> :
    <ul>
        <b>super</b> <i>Arguments</i>
    </ul>
</ul><div style="break-before: page; page-break-before: always;"></div><h1 id="block-statement"><a class="header" href="#block-statement">Block statement</a></h1>
<p><strong>Syntax</strong></p>
<ul>
    <i>Block</i> :
    <ul>
        <b>&#x7B;</b> <i>Directives</i> <b>&#x7D;</b>
    </ul>
</ul><div style="break-before: page; page-break-before: always;"></div><h1 id="labeled-statement"><a class="header" href="#labeled-statement">Labeled statement</a></h1>
<p><strong>Syntax</strong></p>
<ul>
    <i>LabeledStatement</i><sup>ω</sup> :
    <ul>
        <i>Identifier</i> <b>:</b> <i>Substatement</i><sup>ω</sup>
    </ul>
</ul><div style="break-before: page; page-break-before: always;"></div><h1 id="if-statement"><a class="header" href="#if-statement">If statement</a></h1>
<p><strong>Syntax</strong></p>
<ul>
    <i>IfStatement</i><sup>abbrev</sup> :
    <ul>
        <b>if</b> <i>ParenListExpression</i> <i>Substatement</i><sup>abbrev</sup><br>
        <b>if</b> <i>ParenListExpression</i> <i>Substatement</i><sup>noShortIf</sup> <b>else</b> <i>Substatement</i><sup>abbrev</sup>
    </ul>
</ul>
<ul>
    <i>IfStatement</i><sup>full</sup> :
    <ul>
        <b>if</b> <i>ParenListExpression</i> <i>Substatement</i><sup>full</sup><br>
        <b>if</b> <i>ParenListExpression</i> <i>Substatement</i><sup>noShortIf</sup> <b>else</b> <i>Substatement</i><sup>full</sup>
    </ul>
</ul>
<ul>
    <i>IfStatement</i><sup>noShortIf</sup> :
    <ul>
        <b>if</b> <i>ParenListExpression</i> <i>Substatement</i><sup>noShortIf</sup> <b>else</b> <i>Substatement</i><sup>noShortIf</sup>
    </ul>
</ul><div style="break-before: page; page-break-before: always;"></div><h1 id="switch-statements"><a class="header" href="#switch-statements">Switch statements</a></h1>
<p>The switch statement is similiar to that of Java. Unlike in Java, the switch statement does not include fallthroughs.</p>
<pre><code>switch (v) {
    case 0:
    case 1:
        trace("zero or one");
    default:
        trace("other");
}
</code></pre>
<p>The <strong>switch type</strong> statement is used to match the type of a discriminant value.</p>
<pre><code>switch type (v) {
    case (d : Number) {
        // double
    }
    default {
        // no matching case
    }
}
</code></pre>
<p><strong>Syntax</strong></p>
<ul>
    <i>SwitchStatement</i> :
    <ul>
        <b>switch</b> <i>ParenListExpression</i> <b>&#x7B;</b> <i>CaseElements</i><sup>abbrev</sup> <b>&#x7D;</b><br>
        <b>switch</b> [no line break] <b>type</b> <i>ParenListExpression</i> <b>&#x7B;</b> <i>TypeCaseElements</i> <b>&#x7D;</b>
    </ul>
</ul>
<ul>
    <i>CaseElements</i><sup>ω</sup> :
    <ul>
        «empty»<br>
        <i>CaseElement</i><sup>ω</sup><br>
        <i>CaseElements</i><sup>full</sup> <i>CaseElement</i><sup>ω</sup>
    </ul>
</ul>
<ul>
    <i>CaseElement</i><sup>ω</sup> :
    <ul>
        <i>CaseLabel</i><sub>{1,}</sub> <i>CaseDirectives</i><sup>ω</sup>
    </ul>
</ul>
<ul>
    <i>CaseLabel</i> :
    <ul>
        <b>case</b> <i>ListExpression</i><sup>allowIn</sup> <b>:</b><br>
        <b>default :</b>
    </ul>
</ul>
<ul>
    <i>CaseDirectives</i><sup>ω</sup> :
    <ul>
        <i>Directive</i><sup>ω</sup><br>
        <i>CaseDirectives</i><sup>full</sup> <i>Directive</i><sup>ω</sup>
    </ul>
</ul>
<ul>
    <i>TypeCaseElements</i> :
    <ul>
        «empty»<br>
        <i>TypeCaseElement</i><br>
        <i>TypeCaseElements</i> <i>TypeCaseElement</i>
    </ul>
</ul>
<ul>
    <i>TypeCaseElement</i> :
    <ul>
        <b>case &#x28;</b> <i>TypedPattern</i> <b>&#x29;</b> <i>Block</i><br>
        <b>default</b> <i>Block</i>
    </ul>
</ul><div style="break-before: page; page-break-before: always;"></div><h1 id="do-statement"><a class="header" href="#do-statement">Do statement</a></h1>
<p><strong>Syntax</strong></p>
<ul>
    <i>DoStatement</i> :
    <ul>
        <b>do</b> <i>Substatement</i><sup>abbrev</sup> <b>while</b> <i>ParenListExpression</i>
    </ul>
</ul><div style="break-before: page; page-break-before: always;"></div><h1 id="while-statement"><a class="header" href="#while-statement">While statement</a></h1>
<p><strong>Syntax</strong></p>
<ul>
    <i>WhileStatement</i><sup>ω</sup> :
    <ul>
        <b>while</b> <i>ParenListExpression</i> <i>Substatement</i><sup>ω</sup>
    </ul>
</ul><div style="break-before: page; page-break-before: always;"></div><h1 id="for-statements"><a class="header" href="#for-statements">For statements</a></h1>
<p>The <strong>for..in</strong> statement is used to iterate the keys of an object.</p>
<pre><code>for (const key in map) {
    trace(key)
}
</code></pre>
<p>The <strong>for each</strong> statement is used to iterate the values of an object.</p>
<pre><code>for each (const value in array) {
    trace(value)
}
</code></pre>
<p><strong>Syntax</strong></p>
<ul>
    <i>ForStatement</i><sup>ω</sup> :
    <ul>
        <b>for &#x28;</b> <i>ForInitializer</i> <b>;</b> <i>ListExpression</i><sup>allowIn</sup><sub>opt</sub> <b>;</b> <i>ListExpression</i><sup>allowIn</sup><sub>opt</sub> <b>&#x29;</b> <i>Substatement</i><sup>ω</sup><br>
        <b>for &#x28;</b> <i>ForInBinding</i> <b>in</b> <i>ListExpression</i><sup>allowIn</sup> <b>&#x29;</b> <i>Substatement</i><sup>ω</sup><br>
        <b>for</b> [no line break] <b>each &#x28;</b> <i>ForInBinding</i> <b>in</b> <i>ListExpression</i><sup>allowIn</sup> <b>&#x29;</b> <i>Substatement</i><sup>ω</sup>
    </ul>
</ul>
<ul>
    <i>ForInitializer</i> :
    <ul>
        «empty»<br>
        <i>ListExpression</i><sup>noIn</sup><br>
        <i>VariableDefinition</i><sup>noIn</sup>
    </ul>
</ul>
<ul>
    <i>ForInBinding</i> :
    <ul>
        <i>PostfixExpression</i><br>
        <i>VariableDefinitionKind</i> <i>VariableBinding</i><sup>noIn</sup>
    </ul>
</ul><div style="break-before: page; page-break-before: always;"></div><h1 id="continue-statement"><a class="header" href="#continue-statement">Continue statement</a></h1>
<p><strong>Syntax</strong></p>
<ul>
    <i>ContinueStatement</i> :
    <ul>
        <b>continue</b><br>
        <b>continue</b> [no line break] <i>Identifier</i>
    </ul>
</ul><div style="break-before: page; page-break-before: always;"></div><h1 id="break-statement"><a class="header" href="#break-statement">Break statement</a></h1>
<p><strong>Syntax</strong></p>
<ul>
    <i>BreakStatement</i> :
    <ul>
        <b>break</b><br>
        <b>break</b> [no line break] <i>Identifier</i>
    </ul>
</ul><div style="break-before: page; page-break-before: always;"></div><h1 id="with-statement-1"><a class="header" href="#with-statement-1">With statement</a></h1>
<p>The <strong>with</strong> statement is used to declare a <strong>*</strong> binding to the statement's scope. The <strong>*</strong> binding holds the value of the parenthesized expression.</p>
<pre><code>with (o) {
    *.x += 10;
    *.y += 5;
}
</code></pre>
<p><strong>Syntax</strong></p>
<ul>
    <i>WithStatement</i><sup>ω</sup> :
    <ul>
        <b>with</b> <i>ParenListExpression</i> <i>Substatement</i><sup>ω</sup>
    </ul>
</ul><div style="break-before: page; page-break-before: always;"></div><h1 id="return-statement"><a class="header" href="#return-statement">Return statement</a></h1>
<p><strong>Syntax</strong></p>
<ul>
    <i>ReturnStatement</i> :
    <ul>
        <b>return</b><br>
        <b>return</b> [no line break] <i>ListExpression</i><sup>allowIn</sup>
    </ul>
</ul><div style="break-before: page; page-break-before: always;"></div><h1 id="throw-statement"><a class="header" href="#throw-statement">Throw statement</a></h1>
<p><strong>Syntax</strong></p>
<ul>
    <i>ThrowStatement</i> :
    <ul>
        <b>throw</b> [no line break] <i>ListExpression</i><sup>allowIn</sup>
    </ul>
</ul><div style="break-before: page; page-break-before: always;"></div><h1 id="try-statement"><a class="header" href="#try-statement">Try statement</a></h1>
<p><strong>Syntax</strong></p>
<ul>
    <i>TryStatement</i> :
    <ul>
        <b>try</b> <i>Block</i> <i>CatchClauses</i><br>
        <b>try</b> <i>Block</i> <i>CatchClauses</i><sub>opt</sub> <b>finally</b> <i>Block</i>
    </ul>
</ul>
<ul>
    <i>CatchClauses</i> :
    <ul>
        <i>CatchClause</i><br>
        <i>CatchClauses</i> <i>CatchClause</i>
    </ul>
</ul>
<ul>
    <i>CatchClause</i> :
    <ul>
        <b>catch &#x28;</b> <i>TypedPattern</i> <b>&#x29;</b> <i>Block</i>
    </ul>
</ul><div style="break-before: page; page-break-before: always;"></div><h1 id="shockscript-directives"><a class="header" href="#shockscript-directives">ShockScript: Directives</a></h1>
<p><strong>Syntax</strong></p>
<ul>
    <i>Directive</i><sup>ω</sup> :
    <ul>
        <i>EmptyStatement</i><br>
        <i>Statement</i><sup>ω</sup><br>
        <i>ConfigurationConstant</i><sub>opt</sub> <i>Attributes</i><sub>opt</sub> <i>AnnotatableDirective</i><sup>ω</sup><br>
        <i>ConfigurationConstant</i> <i>Block</i><br>
        <i>ImportDirective</i> <i>Semicolon</i><sup>ω</sup><br>
        <i>UseDirective</i> <i>Semicolon</i><sup>ω</sup>
    </ul>
</ul>
<ul>
    <i>AnnotatableDirective</i><sup>ω</sup> :
    <ul>
        <i>NamespaceDefinition</i> <i>Semicolon</i><sup>ω</sup><br>
        <i>VariableDefinition</i><sup>allowIn</sup> <i>Semicolon</i><sup>ω</sup><br>
        <i>FunctionDefinition</i><br>
        <i>ClassDefinition</i><br>
        <i>EnumDefinition</i><br>
        <i>InterfaceDefinition</i><br>
        <i>TypeDefinition</i> <i>Semicolon</i><sup>ω</sup>
    </ul>
</ul>
<ul>
    <i>Directives</i> :
    <ul>
        «empty»<br>
        <i>DirectivesPrefix</i> <i>Directive</i><sup>abbrev</sup>
    </ul>
</ul>
<ul>
    <i>DirectivesPrefix</i> :
    <ul>
        «empty»<br>
        <i>DirectivesPrefix</i> <i>Directive</i><sup>full</sup>
    </ul>
</ul>
<ul>
    <i>ConfigurationConstant</i> :
    <ul>
        <i>Identifier</i> <b>::</b> <i>IdentifierName</i>
    </ul>
</ul><div style="break-before: page; page-break-before: always;"></div><h1 id="attributes-1"><a class="header" href="#attributes-1">Attributes</a></h1>
<p>Attributes are in the sequence of meta-data followed by modifiers. A parser shall disambiguate expressions into attributes as applicable.</p>
<p><strong>Syntax</strong></p>
<ul>
    <i>Attributes</i> :
    <ul>
        <i>Attribute</i> <i>AttributeLineBreakRestriction</i><br>
        <i>AttributeCombination</i> <i>AttributeLineBreakRestriction</i>
    </ul>
</ul>
<ul>
    <i>AttributeCombination</i> :
    <ul>
        <i>Attribute</i> <i>AttributeLineBreakRestriction</i> <i>Attributes</i>
    </ul>
</ul>
<ul>
    <i>BlockAttributes</i> :
    <ul>
        <i>Metadata</i><br>
        <i>BlockAttributes</i> <i>Metadata</i>
    </ul>
</ul>
<ul>
    <i>AttributeLineBreakRestriction</i> :
    <ul>
        no line break if the previous and offending tokens match an <i>IdentifierName</i>
    </ul>
</ul>
<ul>
    <i>Attribute</i> :
    <ul>
        <i>Metadata</i><br>
        <i>UserAttribute</i><br>
        <i>ReservedNamespace</i><br>
        <b>final</b><br>
        <b>native</b><br>
        <b>static</b><br>
        <b>abstract</b><br>
        <b>override</b>
    </ul>
</ul>
<ul>
    <i>UserAttribute</i> :
    <ul>
        <i>Identifier</i><br>
        <i>UserAttribute</i> <b>.</b> <i>IdentifierName</i>
    </ul>
</ul>
<ul>
    <i>Metadata</i> :
    <ul>
        <i>MetadataPreRestriction</i> <b>&#x5B;</b> <i>MetadataForm</i> <b>&#x5D;</b>&#x5D;<br>
        <i>MetadataPreRestriction</i> <b>&#x5B;</b> <i>MetadataForm</i> <i>MetadataTrailingComma</i> <b>&#x5D;</b>
    </ul>
</ul>
<ul>
    <i>MetadataPreRestriction</i> :
    <ul>
        if the <i>Metadata</i> is in the beginning of <i>Attributes</i> or if the <i>Metadata</i> appears before an <i>IdentifierName</i> in <i>Attributes</i>
    </ul>
</ul>
<ul>
    <i>MetadataTrailingComma</i> :
    <ul>
        comma <b>,</b> if the <i>Metadata</i> is the first occurrence in <i>Attributes</i> or <i>BlockAttributes</i>
    </ul>
</ul>
<ul>
    <i>MetadataForm</i> :
    <ul>
        <i>MetadataName</i><br>
        <i>MetadataName</i> <b>&#x28;&#x29;</b><br>
        <i>MetadataName</i> <b>&#x28;</b> <i>MetadataEntryList</i> <b>&#x29;</b>
    </ul>
</ul>
<ul>
    <i>MetadataName</i> :
    <ul>
        <i>Identifier</i><br>
        <i>Identifier</i> <b>::</b> <i>IdentifierName</i>
    </ul>
</ul>
<ul>
    <i>MetadataEntryList</i> :
    <ul>
        <i>MetadataEntry</i><br>
        <i>MetadataEntryList</i> <b>,</b> <i>MetadataEntry</i>
    </ul>
</ul>
<ul>
    <i>MetadataEntry</i> :
    <ul>
        <i>MetadataName</i><br>
        <i>StringLiteral</i><br>
        <i>MetadataName</i> <b>=</b> <i>StringLiteral</i>
    </ul>
</ul><div style="break-before: page; page-break-before: always;"></div><h1 id="import-directive"><a class="header" href="#import-directive">Import directive</a></h1>
<p><strong>Syntax</strong></p>
<ul>
    <i>ImportDirective</i> :
    <ul>
        <b>import</b> <i>PackageName</i> <b>. *</b><br>
        <b>import</b> <i>PackageName</i> <b>.</b> <i>IdentifierName</i><br>
        <b>import</b> <i>Identifier</i> <b>=</b> <i>PackageName</i> <b>. *</b><br>
        <b>import</b> <i>Identifier</i> <b>=</b> <i>PackageName</i> <b>.</b> <i>IdentifierName</i>
    </ul>
</ul><div style="break-before: page; page-break-before: always;"></div><h1 id="use-directive"><a class="header" href="#use-directive">Use directive</a></h1>
<p>The <strong>use namespace</strong> directive is used to contribute a namespace to the open namespace list of the enclosing scope.</p>
<pre><code>use namespace ns1
</code></pre>
<p><strong>Syntax</strong></p>
<ul>
    <i>UseDirective</i> :
    <ul>
        <b>use namespace</b> <i>ListExpression</i><sup>allowIn</sup>
    </ul>
</ul><div style="break-before: page; page-break-before: always;"></div><h1 id="shockscript-definitions"><a class="header" href="#shockscript-definitions">ShockScript: Definitions</a></h1>
<div style="break-before: page; page-break-before: always;"></div><h1 id="namespace-definition"><a class="header" href="#namespace-definition">Namespace definition</a></h1>
<p>The namespace definition may be used to define a namespace that may be used for protecting or versioning other definitions and XML data processing.</p>
<pre><code>namespace ns1
namespace ns2 = "http://example.com/secret"
</code></pre>
<p><strong>Syntax</strong></p>
<ul>
    <i>NamespaceDefinition</i> :
    <ul>
        <b>namespace</b> <i>IdentifierName</i><br>
        <b>namespace</b> <i>IdentifierName</i> <b>=</b> <i>AssignmentExpression</i><sup>allowIn</sup>
    </ul>
</ul><div style="break-before: page; page-break-before: always;"></div><h1 id="variable-definition"><a class="header" href="#variable-definition">Variable definition</a></h1>
<p><strong>Syntax</strong></p>
<ul>
    <i>VariableDefinition</i><sup>β</sup> :
    <ul>
        <i>VariableDefinitionKind</i> <i>VariableBindingList</i><sup>β</sup>
    </ul>
</ul>
<ul>
    <i>VariableDefinitionKind</i> :
    <ul>
        <b>var</b><br>
        <b>const</b>
    </ul>
</ul>
<ul>
    <i>VariableBindingList</i><sup>β</sup> :
    <ul>
        <i>VariableBinding</i><sup>β</sup><br>
        <i>VariableBindingList</i><sup>β</sup> <b>,</b> <i>VariableBinding</i><sup>β</sup>
    </ul>
</ul>
<ul>
    <i>VariableBinding</i><sup>β</sup> :
    <ul>
        <i>TypedDestructuring</i> <i>VariableInitialization</i><sup>β</sup>
    </ul>
</ul>
<ul>
    <i>VariableInitialization</i><sup>β</sup> :
    <ul>
        «empty»<br>
        <b>=</b> <i>AssignmentExpression</i><sup>β</sup>
    </ul>
</ul><div style="break-before: page; page-break-before: always;"></div><h1 id="function-definition"><a class="header" href="#function-definition">Function definition</a></h1>
<p><strong>Syntax</strong></p>
<ul>
    <i>FunctionDefinition</i> :
    <ul>
        <b>function</b> <i>FunctionName</i> <i>TypeParameters</i><sub>opt</sub> <i>FunctionCommon</i><sup>allowIn</sup>
    </ul>
</ul>
<h2 id="function-name"><a class="header" href="#function-name">Function name</a></h2>
<p><strong>Syntax</strong></p>
<ul>
    <i>FunctionName</i> :
    <ul>
        <i>IdentifierName</i><br>
        <b>get</b> [no line break] <i>IdentifierName</i><br>
        <b>set</b> [no line break] <i>IdentifierName</i>
    </ul>
</ul>
<p><em>FunctionName</em> is used inside <em>FunctionDefinition</em>.</p>
<pre><code>function f(): void {}
function get x(): Number (impl.x)
function set x(v: Number): void { impl.x = v }
</code></pre>
<p><em>TypeParameters</em> may not appear in a function definition defining a getter, setter or constructor.</p>
<h2 id="function-body"><a class="header" href="#function-body">Function body</a></h2>
<p><strong>Syntax</strong></p>
<pre><code>function f():Number 10

function f():void {
    // code
}
</code></pre>
<ul>
    <i>FunctionCommon</i><sup>β</sup> :
    <ul>
        <i>FunctionSignature</i><br>
        <i>FunctionSignature</i> [lookahead ∉ { <b>&#x7B;</b> }] [inline, or in a greater indentation, or lookahead = **&#x28;**] <i>AssignmentExpression</i><sup>β</sup><br>
        <i>FunctionSignature</i> <i>Block</i>
    </ul>
</ul>
<h2 id="function-signature"><a class="header" href="#function-signature">Function signature</a></h2>
<p><strong>Syntax</strong></p>
<ul>
    <i>FunctionSignature</i> :
    <ul>
        <b>(</b> <i>Parameters</i> <b>)</b> <i>ResultType</i>
    </ul>
</ul>
<ul>
    <i>ResultType</i> :
    <ul>
        «empty»<br>
        <b>:</b> <i>TypeExpression</i>
    </ul>
</ul>
<h2 id="parameter-list"><a class="header" href="#parameter-list">Parameter list</a></h2>
<p><strong>Syntax</strong></p>
<ul>
    <i>Parameters</i> :
    <ul>
        «empty»<br>
        <i>NonemptyParameters</i>
    </ul>
</ul>
<ul>
    <i>NonemptyParameters</i> :
    <ul>
        <i>Parameter</i><br>
        <i>Parameter</i> <b>,</b> <i>NonemptyParameters</i><br>
        <i>RestParameter</i>
    </ul>
</ul>
<ul>
    <i>Parameter</i> :
    <ul>
        <i>TypedPattern</i><br>
        <i>TypedPattern</i> <b>=</b> <i>AssignmentExpression</i><sup>allowIn</sup>
    </ul>
</ul>
<ul>
    <i>RestParameter</i> :
    <ul>
        <b>...</b> <i>TypedPattern</i>
    </ul>
</ul><div style="break-before: page; page-break-before: always;"></div><h1 id="class-definition"><a class="header" href="#class-definition">Class definition</a></h1>
<p><strong>Syntax</strong></p>
<p>Nested classes are not allowed; classes are only allowed in package blocks and top-level region.</p>
<ul>
    <i>ClassDefinition</i> :
    <ul>
        <b>class</b> <i>IdentifierName</i> <i>TypeParameters</i><sub>opt</sub> <i>Inheritance</i> <i>Block</i>
    </ul>
</ul>
<ul>
    <i>TypeParameters</i> :
    <ul>
        <b>. &lt;</b> <i>TypeParameterList</i> <i>GenericGreaterThan</i>
    </ul>
</ul>
<ul>
    <i>TypeParameterList</i> :
    <ul>
        <i>TypeParameter</i><br>
        <i>TypeParameterList</i> <b>,</b> <i>TypeParameter</i>
    </ul>
</ul>
<ul>
    <i>TypeParameter</i> :
    <ul>
        <i>Identifier</i>
    </ul>
</ul>
<h2 id="class-inheritance"><a class="header" href="#class-inheritance">Class inheritance</a></h2>
<p><strong>Syntax</strong></p>
<ul>
    <i>Inheritance</i> :
    <ul>
        «empty»<br>
        <b>extends</b> <i>TypeExpression</i><br>
        <b>implements</b> <i>TypeExpressionList</i><br>
        <b>extends</b> <i>TypeExpression</i> <b>implements</b> <i>TypeExpressionList</i>
    </ul>
</ul><div style="break-before: page; page-break-before: always;"></div><h1 id="enum-definition"><a class="header" href="#enum-definition">Enum definition</a></h1>
<p><strong>Syntax</strong></p>
<p>Nested enumerations are not allowed; enumerations are only allowed in package blocks and top-level region.</p>
<ul>
    <i>EnumDefinition</i> :
    <ul>
        <b>enum</b> <i>IdentifierName</i> <i>Block</i>
    </ul>
</ul><div style="break-before: page; page-break-before: always;"></div><h1 id="interface-definition"><a class="header" href="#interface-definition">Interface definition</a></h1>
<p><strong>Syntax</strong></p>
<p>Nested interfaces are not allowed; interfaces are only allowed in package blocks and top-level region.</p>
<p>The interface block must only contain function definitions.</p>
<ul>
    <i>InterfaceDefinition</i> :
    <ul>
        <b>interface</b> <i>IdentifierName</i> <i>TypeParameters</i><sub>opt</sub> <i>ExtendsList</i> <i>Block</i>
    </ul>
</ul>
<h2 id="interface-inheritance"><a class="header" href="#interface-inheritance">Interface inheritance</a></h2>
<p><strong>Syntax</strong></p>
<ul>
    <i>ExtendsList</i> :
    <ul>
        «empty»<br>
        <b>extends</b> <i>TypeExpressionList</i>
    </ul>
</ul><div style="break-before: page; page-break-before: always;"></div><h1 id="type-definition"><a class="header" href="#type-definition">Type definition</a></h1>
<p>A type definition is used to define an alias to an existing type.</p>
<p><strong>Syntax</strong></p>
<pre><code>type M = Map.&lt;Number, Number&gt;
</code></pre>
<p>Type definitions are only allowed in package blocks and top-level region.</p>
<ul>
    <i>TypeDefinition</i> :
    <ul>
        <b>type</b> <i>IdentifierName</i> <i>TypeParameters</i><sub>opt</sub> <b>=</b> <i>TypeExpression</i>
    </ul>
</ul><div style="break-before: page; page-break-before: always;"></div><h1 id="package-definition"><a class="header" href="#package-definition">Package definition</a></h1>
<p><strong>Syntax</strong></p>
<ul>
    <i>PackageDefinition</i> :
    <ul>
        <b>package</b> <i>PackageName</i><sub>opt</sub> <i>Block</i>
    </ul>
</ul>
<p>A <em>PackageDefinition</em> may be used in a <em>Program</em> before any <em>Directive</em> that is not a <em>PackageDefinition</em> is used.</p>
<h2 id="package-name"><a class="header" href="#package-name">Package name</a></h2>
<p><strong>Syntax</strong></p>
<ul>
    <i>PackageName</i> :
    <ul>
        <i>Identifier</i><br>
        <i>PackageName</i> <b>.</b> <i>IdentifierName</i>
    </ul>
</ul><div style="break-before: page; page-break-before: always;"></div><h1 id="program-definition"><a class="header" href="#program-definition">Program definition</a></h1>
<p><strong>Syntax</strong></p>
<ul>
    <i>Program</i> :
    <ul>
        <i>Directives</i><br>
        <i>PackageDefinition</i> <i>Program</i>
    </ul>
</ul>
                    </main>

                    <nav class="nav-wrapper" aria-label="Page navigation">
                        <!-- Mobile navigation buttons -->


                        <div style="clear: both"></div>
                    </nav>
                </div>
            </div>

            <nav class="nav-wide-wrapper" aria-label="Page navigation">

            </nav>

        </div>




        <script>
            window.playground_copyable = true;
        </script>


        <script src="elasticlunr.min.js"></script>
        <script src="mark.min.js"></script>
        <script src="searcher.js"></script>

        <script src="clipboard.min.js"></script>
        <script src="highlight.js"></script>
        <script src="book.js"></script>

        <!-- Custom JS scripts -->

        <script>
        window.addEventListener('load', function() {
            window.setTimeout(window.print, 100);
        });
        </script>

    </div>
    </body>
</html>
